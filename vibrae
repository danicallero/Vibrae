#!/bin/bash
# SPDX-License-Identifier: GPL-3.0-or-later
# Vibrae CLI: install, run, inspect.
# Usage: vibrae <command> [args]

# Structure (search for the SECTION headers):
#   00 Prelude & Globals
#   01 Path Resolution & Environment Files
#   02 Colors & Output Helpers
#   03 Generic Utilities (kv store, truthy, etc.)
#   04 Environment Management (ensure, sync, set/get)
#   05 Encryption (sops helpers)
#   06 Commands (install/start/stop/...)
#   07 Pi Helpers
#   07b Mac Helpers
#   08 Interactive Shell
#   09 Dispatch & Main

########################################
## 00 PRELUDE & GLOBALS
########################################
set -o pipefail
IFS=$'\n\t'

# Fallback minimal error printer before colors load (overridden later with colors)
err(){ printf 'x %s\n' "$*" 1>&2; }

VERSION="0.4.2"

trap_handler(){
  local rc=$?; local ln=${LINENO}
  # Skip trap until fully init
  if [ -z "${_VIBRAE_TRAP_READY:-}" ] || [ -n "${_VIBRAE_SUPPRESS_TRAP:-}" ]; then return; fi
  err "unexpected error (line ${ln})"; return $rc
}
# Trap disabled (too noisy)
unset _VIBRAE_SUPPRESS_TRAP 2>/dev/null || true

# Enable -u later
DEFER_SET_U=1

########################################
## 01 PATH RESOLUTION & ENV FILES
########################################
resolve_self(){
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir; dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  printf '%s' "$src"
}
SCRIPT_PATH="$(resolve_self)"
ROOT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
ENV_FILE="$ROOT_DIR/config/env/.env.backend"
# Example env path (used by ensure_env)
ENV_EXAMPLE="$ROOT_DIR/config/env/.env.backend.example"
# Default logs directory (can be overridden via environment)
: "${LOG_DIR:=$ROOT_DIR/logs}"

########################################
## 02 COLORS & OUTPUT HELPERS
########################################
# Detect terminal support and initialize color/style variables
if [ -t 1 ] && command -v tput >/dev/null 2>&1; then
  # Basic ANSI colors via tput; fall back to empty if term lacks colors
  if [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
    BOLD="$(tput bold)"; RESET="$(tput sgr0)"
    RED="$(tput setaf 1)"; GREEN="$(tput setaf 2)"; YELLOW="$(tput setaf 3)"
    BLUE="$(tput setaf 4)"; CYAN="$(tput setaf 6)"; GREY="$(tput setaf 8 2>/dev/null || tput setaf 7)"
  else
    BOLD=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; GREY=""; CYAN=""
  fi
else
  BOLD=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; GREY=""; CYAN=""
fi

# Respect NO_COLOR (https://no-color.org/) and VIBRAE_NO_COLOR=1 to disable any styling
if [ -n "${NO_COLOR-}" ] || [ "${VIBRAE_NO_COLOR-0}" = "1" ]; then
  BOLD=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; GREY=""; CYAN=""
fi

# Centralized styles/icons
STYLE_HEADER="${BOLD}${CYAN}"
STYLE_BANNER="${BOLD}${BLUE}"
ICON_OK="✔"; ICON_WARN="!"; ICON_ERR="✖"

# Styled output helpers
ok(){ printf "%b%s%b %s\n" "$GREEN" "$ICON_OK" "$RESET" "$*"; }
warn(){ printf "%b%s%b %s\n" "$YELLOW" "$ICON_WARN" "$RESET" "$*"; }
err(){ printf "%b%s%b %s\n" "$RED" "$ICON_ERR" "$RESET" "$*" 1>&2; }
# Styled header and separator for improved readability
hdr(){ printf "%b%s%s%s%b\n" "$STYLE_HEADER" "" "$*" "" "$RESET"; }
# Draw a line with subtle grey when available
line(){
  local ch
  if [ -n "$GREY" ]; then
    ch="─"
    printf "%b" "$GREY"
  else
    ch="-"
  fi
  printf '%s\n' "$(printf '%*s' 50 '' | tr ' ' "$ch")"
  [ -n "$GREY" ] && printf "%b" "$RESET" || true
}
section(){ echo; hdr "$1"; line; }

BANNER_WIDTH=50
#banner(){ printf "=== %bVibrae%b — Sound, simplified===\n" "$BOLD" "$RESET"; }
banner(){
  # UTF-8 detection: be safe even under `set -u` and allow opt-out via VIBRAE_FORCE_ASCII=1
  local title=" Vibrae — Sound, simplified "
  local utf8=0
  # If user forces ASCII, keep ascii; else detect via locale envs or `locale`
  if [ "${VIBRAE_FORCE_ASCII-0}" = "1" ]; then
    utf8=0
  else
    if (locale 2>/dev/null | grep -qi 'UTF-8') || \
       (printf '%s' "${LC_ALL-}${LC_CTYPE-}${LANG-}" | grep -qi 'UTF-8'); then
      utf8=1
    fi
  fi
  local tl tr bl br hl vl
  if [ "$utf8" -eq 1 ]; then
    hl='═'; vl='║'; tl='╔'; tr='╗'; bl='╚'; br='╝'
  else
    hl='='; vl='|'; tl='+'; tr='+'; bl='+'; br='+'
  fi
  local border; border="$(printf '%s' "$(printf '%*s' "$BANNER_WIDTH" '')" | tr ' ' "$hl")"
  printf "%b%s%s%s%b\n" "$STYLE_BANNER" "$tl" "$border" "$tr" "$RESET"
  local pad=$(( (BANNER_WIDTH - ${#title}) / 2 ))
  local pad2=$(( BANNER_WIDTH - pad - ${#title} ))
  printf "%b%s%*s%s%*s%s%b\n" "$STYLE_BANNER" "$vl" "$pad" "" "$title" "$pad2" "" "$vl" "$RESET"
  printf "%b%s%s%s%b\n" "$STYLE_BANNER" "$bl" "$border" "$br" "$RESET"
}
HELP_BANNER_SHOWN=""
help_banner(){ if [ -z "$HELP_BANNER_SHOWN" ]; then banner; HELP_BANNER_SHOWN=1; fi }

license_notice(){ printf "%bVibrae%b (GPLv3, no warranty)\n" "$BOLD" "$RESET"; }
contact_information(){ printf "%bContact%b\n" "$BOLD" "$RESET"; printf "Issues: GitHub repo (./vibrae github). Email: vibrae@danicallero.es\n"; }

usage(){
  banner
  echo "Note: Commands are cross-platform (macOS/Linux, incl. Pi) unless listed under 'Raspberry Pi' or 'macOS' helpers."
  echo
  section "Core"; cat <<EOF
  ${BOLD}version${RESET}             Show CLI version
  ${BOLD}install${RESET}             Install/update dependencies (scripts/app/setup.sh)
  ${BOLD}start${RESET} | up          Start all services (run.sh)
  ${BOLD}stop${RESET} | down         Stop all services (stop.sh)
  ${BOLD}restart${RESET}             Stop then start
  ${BOLD}status${RESET}              Show service status (process + health)
  ${BOLD}logs${RESET} [name] [n]     Tail logs (backend|player|serve|cloudflared). Default all; n=100
EOF
  section "Environment & Secrets"; cat <<EOF
  ${BOLD}env show${RESET}            Print .env (aliases: env ls, env cat)
  ${BOLD}env edit${RESET}            Edit .env
  ${BOLD}env set${RESET} KEY=VALUE   Set or add a key
  ${BOLD}env sync${RESET}            Add any missing recommended keys
  ${BOLD}env encrypt${RESET}         Encrypt backend env (.env.backend)
  ${BOLD}env decrypt${RESET}         Decrypt backend env
  ${BOLD}env edit-sec${RESET}        Decrypt, edit, re-encrypt backend env
  ${BOLD}env f-encrypt${RESET}       Encrypt frontend env (EXPO_PUBLIC_*)
  ${BOLD}env f-decrypt${RESET}       Decrypt frontend env
  ${BOLD}env f-edit-sec${RESET}      Decrypt, edit, re-encrypt frontend env
  ${BOLD}env help${RESET}            Env-only help & tips
EOF
  section "Database"; echo "  ${BOLD}db init${RESET}             Create tables & seed admin (if absent)" 
  section "Music Source"; cat <<EOF
  ${BOLD}source detect${RESET}       Show resolved source (folder:/path or usb:LABEL)
  ${BOLD}autostart${RESET} on|off    Toggle AUTOSTART (auto start on shell entry)
EOF
  section "Diagnostics"; cat <<EOF
  ${BOLD}check-env${RESET}           Validate .env values
  ${BOLD}doctor${RESET}              Check required tools & deps
EOF
  section "Frontend"; cat <<EOF
  ${BOLD}front restart${RESET}       Restart only static server
  ${BOLD}front build|export${RESET}  Build/export static web (Expo)
  ${BOLD}front-build${RESET}         Build/export static web (Expo) [alias]
EOF
  section "Web & URLs"; cat <<EOF
  ${BOLD}open${RESET}                Open web UI
  ${BOLD}url${RESET}                 Print local/public URLs
EOF
  section "Aliases"; cat <<EOF
  ahelp                  Show alias list
  st  -> status          ce -> check-env
  ce  -> check-env       doc -> doctor
  sh  -> shell           ls-env|env ls|env cat -> env show
  env get KEY            Print single env value
EOF
  section "Systemd (Linux)"; cat <<EOF
  ${BOLD}systemd install${RESET}     Setup services (systemd, nginx)
  ${BOLD}systemd start|stop|status${RESET} Manage services via systemd
  ${BOLD}systemd logs${RESET} [unit] Tail journal for a unit
  ${BOLD}systemd sudoers${RESET}     Add passwordless sudoers
  (aliases: ${BOLD}sys${RESET}, ${BOLD}pi${RESET})
EOF
  section "macOS (helpers)"; cat <<EOF
  ${BOLD}mac sudoers${RESET}         Add passwordless sudoers
EOF
  section "Misc"; cat <<EOF
  ${BOLD}shell${RESET}               Interactive shell
  ${BOLD}clear${RESET}               Clear the screen
  ${BOLD}ahelp${RESET}               Show command aliases
  ${BOLD}help${RESET}                Show this help
EOF
  line;echo
}

onboarding_message(){
  echo; warn "Vibrae is not installed yet (missing .installed or venv)"; cat <<'EOM'
Next steps:
  1. Run: vibrae install        # installs deps
  2. Edit env: vibrae env edit  # or: vibrae env sync
  3. Init DB: vibrae db init
  4. Start: vibrae start

Shortcut:
  vibrae install && vibrae db init && vibrae start
EOM
}

########################################
## 03 GENERIC UTILITIES
########################################
ensure_env(){
  # Warn about legacy root .env (not auto-migrated)
  if [ -f "$ROOT_DIR/.env" ]; then warn "root .env is ignored; run 'vibrae env migrate' if needed"; fi
  # If only encrypted env exists, inform user
  if [ ! -f "$ENV_FILE" ] && [ -f "${ENV_FILE}.enc" ]; then
    warn "found encrypted backend env ($(basename "${ENV_FILE}.enc")) but no plaintext; decrypt with: vibrae env decrypt"; return 0; fi
  if [ ! -f "$ENV_FILE" ]; then
    mkdir -p "$(dirname "$ENV_FILE")" 2>/dev/null || true
    if [ -f "$ENV_EXAMPLE" ]; then cp "$ENV_EXAMPLE" "$ENV_FILE"; ok "created $(basename "$ENV_FILE") from example"; else cat > "$ENV_FILE" <<'EOENV'
# Vibrae environment
BACKEND_PORT=8000
BACKEND_MODULE=apps.api.src.vibrae_api.main:app
FRONTEND_PORT=9081
FRONTEND_DIST=/apps/web/dist
MUSIC_MODE=folder
MUSIC_DIR=music
SECRET_KEY=change-me-please
LOG_LEVEL=INFO
EOENV
      ok "initialized $(basename "$ENV_FILE") with defaults"
    fi
  fi
  if ! grep -qE '^[A-Z0-9_]+=.*' "$ENV_FILE"; then warn "env file has no KEY= entries; add variables or run 'vibrae env sync'"; fi
}

run_script(){
  local script="$1" candidate
  if [ -f "$ROOT_DIR/$script" ]; then candidate="$ROOT_DIR/$script"; elif [ -f "$ROOT_DIR/scripts/app/$script" ]; then candidate="$ROOT_DIR/scripts/app/$script"; else err "script not found: $script (looked in . and scripts/app)"; return 1; fi
  [ -x "$candidate" ] || chmod +x "$candidate" 2>/dev/null || true
  (cd "$ROOT_DIR" && bash "$candidate")
}

# Colorize common bracketed tags from external script output
colorize_stream(){
  # Only colorize when stdout is a TTY; otherwise pass through
  if [ -t 1 ]; then
  awk -v G="$GREEN" -v Y="$YELLOW" -v C="$CYAN" -v R="$RED" -v RST="$RESET" '
      { line=$0;
    gsub(/\[ok\]/,    G "[ok]" RST, line);
    gsub(/\[warn\]/,  Y "[warn]" RST, line);
    gsub(/\[info\]/,  C "[info]" RST, line);
    gsub(/\[error\]/, R "[error]" RST, line);
        print line;
      }'
  else
    cat
  fi
}
kv_set(){ local key="$1" val="$2" tmp; ensure_env; tmp="$(mktemp 2>/dev/null || true)"; [ -n "$tmp" ] || tmp="${ENV_FILE}.tmp.$$"; awk -v K="$key" -v V="$val" 'BEGIN{ set=0 } /^[#[:space:]]/ { print; next } $0 ~ "^"K"=" { if(!set){ print K"="V; set=1 } ; next } { print } END{ if(!set) print K"="V }' "$ENV_FILE" > "$tmp" && mv "$tmp" "$ENV_FILE"; }
kv_get(){ local key="$1"; [ -f "$ENV_FILE" ] || return 1; grep -E "^${key}=" "$ENV_FILE" | head -n1 | sed -E "s/^${key}=//"; }

# Frontend env utilities
FRONT_ENV_FILE="$ROOT_DIR/config/env/.env.frontend"
FRONT_ENV_EXAMPLE="$ROOT_DIR/config/env/.env.frontend.example"
ensure_front_env(){
  mkdir -p "$(dirname "$FRONT_ENV_FILE")" 2>/dev/null || true
  if [ ! -f "$FRONT_ENV_FILE" ]; then
    if [ -f "$FRONT_ENV_EXAMPLE" ]; then cp "$FRONT_ENV_EXAMPLE" "$FRONT_ENV_FILE"; ok "created $(basename "$FRONT_ENV_FILE") from example"; else
      cat > "$FRONT_ENV_FILE" <<'EOF_FE'
# Vibrae frontend environment (EXPO_PUBLIC_* keys recommended)
EXPO_PUBLIC_API_BASE=/api
EOF_FE
      ok "initialized $(basename "$FRONT_ENV_FILE") with defaults"
    fi
  fi
}
f_kv_set(){ local key="$1" val="$2" tmp; ensure_front_env; tmp="$(mktemp 2>/dev/null || true)"; [ -n "$tmp" ] || tmp="${FRONT_ENV_FILE}.tmp.$$"; awk -v K="$key" -v V="$val" 'BEGIN{ set=0 } /^[#[:space:]]/ { print; next } $0 ~ "^"K"=" { if(!set){ print K"="V; set=1 } ; next } { print } END{ if(!set) print K"="V }' "$FRONT_ENV_FILE" > "$tmp" && mv "$tmp" "$FRONT_ENV_FILE"; }
f_kv_get(){ local key="$1"; [ -f "$FRONT_ENV_FILE" ] || return 1; grep -E "^${key}=" "$FRONT_ENV_FILE" | head -n1 | sed -E "s/^${key}=//"; }

# helpers
truthy(){ case "$(echo "$1" | tr '[:upper:]' '[:lower:]')" in true|1|yes|on) return 0;; *) return 1;; esac }
is_uvicorn_running(){ pgrep -f "uvicorn" >/dev/null 2>&1 || return 1; }

autostart_maybe_start(){ ensure_env; local as; as="$(kv_get AUTOSTART)"; if truthy "$as"; then if is_uvicorn_running; then ok "AUTOSTART on; already running"; else if [ ! -f "$ROOT_DIR/.installed" ] || [ ! -d "$ROOT_DIR/venv" ]; then warn "AUTOSTART on but setup not completed; run scripts/app/setup.sh first"; else warn "AUTOSTART on; starting services"; cmd_start; fi; fi; return 0; fi; return 1; }

########################################
## 04 ENVIRONMENT MANAGEMENT COMMANDS
########################################

cmd_install(){ run_script scripts/app/setup.sh; }
cmd_start(){
  # Require install stamp and venv
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup has not been run. Run: scripts/app/setup.sh or 'vibrae install'"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv. Run: scripts/app/setup.sh"; return 1; fi
  run_script run.sh;
}
cmd_stop(){ run_script stop.sh; }
cmd_restart(){ [ -f "$ROOT_DIR/.installed" ] || { err "setup has not been run. Run: scripts/app/setup.sh or 'vibrae install'"; return 1; }; [ -d "$ROOT_DIR/venv" ] || { err "missing venv. Run: scripts/app/setup.sh"; return 1; }; license_notice; cmd_stop || true; cmd_start; }

service_row(){ local name="$1" patt="$2" psout="$3"; if echo "$psout" | grep -E "$patt" | grep -v grep >/dev/null; then printf "  %b●%b %-12s %brunning%b\n" "$GREEN" "$RESET" "$name" "$GREEN" "$RESET"; else printf "  %b○%b %-12s %bstopped%b\n" "$GREY" "$RESET" "$name" "$GREY" "$RESET"; fi }
cmd_status(){
  banner
  local psout; psout="$(/bin/ps aux || ps -ef || true)"
  section "Services"
  service_row "uvicorn" "uvicorn" "$psout"
  service_row "static-serve" "(serve -s|npx serve)" "$psout"
  service_row "cloudflared" "cloudflared" "$psout"

  # Frontend mode detection (process-level)
  local mode="backend"
    if echo "$psout" | grep -E "(serve -s|npx serve)" >/dev/null; then mode="npx"; fi
  
    printf "\nFrontend: %s\n" "$mode"
  
    # Health via backend
    local api_url="http://127.0.0.1/api/health"
    local json; json="$(curl -s --max-time 1 "$api_url" 2>/dev/null || echo '')"
    if [ -n "$json" ]; then
      local backend fe fe_mode player proxy cf fe_srv
      backend=$(echo "$json" | sed -n 's/.*"backend"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
      fe=$(echo "$json" | sed -n 's/.*"frontend"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
      fe_mode=$(echo "$json" | sed -n 's/.*"frontend_mode"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
      player=$(echo "$json" | sed -n 's/.*"player"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
      proxy=$(echo "$json" | sed -n 's/.*"proxy"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
      cf=$(echo "$json" | sed -n 's/.*"cloudflared"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
      fe_srv=$(echo "$json" | sed -n 's/.*"frontend_server"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
  
      # If backend reports frontend as unknown, try to derive from local process view
      if [ -z "$fe" ] || [ "$fe" = "unknown" ]; then
        if [ "$mode" = "npx" ]; then fe="served"; fe_mode="npx";
        elif echo "$psout" | grep -E "nginx" >/dev/null; then fe="nginx"; fe_mode="nginx";
        else fe="backend"; fi
      fi
  
      section "Health"
      # Backend
      if [ "$backend" = "ok" ]; then printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Backend" "running"; else printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Backend" "stopped"; fi
      # Player
      if [ "$player" = "running" ]; then printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Player" "running"; else printf "  %b◐%b %-12s %s\n" "$YELLOW" "$RESET" "Player" "idle"; fi
      # Frontend
      local fe_label
      if [ -n "${fe:-}" ] && [ "${fe}" != "unknown" ]; then
        fe_label="good"
        printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Frontend" "${fe_label} (mode=${fe_mode:-$mode})"
      else
        fe_label="unknown"
        printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Frontend" "${fe_label}"
      fi
      # Proxy
      printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Proxy" "${proxy:-unknown}"
      # Tunnel
      printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Tunnel" "${cf:-unknown}"
    else
      # API unreachable -> present a helpful fallback Health view based on processes
      section "Health"
      # Backend: check uvicorn process
      if echo "$psout" | grep -E "uvicorn" | grep -v grep >/dev/null; then printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Backend" "running"; else printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Backend" "stopped"; fi
      # Player: best-effort unknown/idle
      printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Player" "unknown (API unreachable)"
      # Frontend: derive from process-level mode detection and mark as good when likely healthy
      if [ "$mode" = "npx" ]; then
        printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Frontend" "good (mode=npx)"
      elif echo "$psout" | grep -E "nginx" >/dev/null; then
        printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Frontend" "good (mode=nginx)"
      elif echo "$psout" | grep -E "uvicorn" | grep -v grep >/dev/null; then
        printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Frontend" "good (mode=backend)"
      else
        printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Frontend" "unknown"
      fi
      # Proxy
      if echo "$psout" | grep -E "nginx" >/dev/null; then printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Proxy" "nginx"; else printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Proxy" "none"; fi
      # Tunnel
      if echo "$psout" | grep -E "cloudflared" >/dev/null; then printf "  %b●%b %-12s %s\n" "$GREEN" "$RESET" "Tunnel" "enabled"; else printf "  %b○%b %-12s %s\n" "$GREY" "$RESET" "Tunnel" "disabled"; fi
      printf "\nAPI (/api/health): unreachable\n"
    fi
}

cmd_logs(){
  mkdir -p "$LOG_DIR" 2>/dev/null || true
  local name="$1"; shift || true
  local lines="${1:-100}"

  if [ -z "$name" ]; then
    for f in backend player serve cloudflared; do
      section "$f.log"
      tail -n "$lines" "$LOG_DIR/$f.log" 2>/dev/null | colorize_stream || warn "no $f.log"
      echo
    done
  else
    section "$name.log"
    tail -n "$lines" "$LOG_DIR/$name.log" 2>/dev/null | colorize_stream || err "no such log: $name"
  fi
}

cmd_front_restart(){
  case "${1-}" in -h|--help|help) _help_front_restart; return 0;; esac
  banner; section "Frontend restart"
  pkill -f "(serve -s|npx serve)" >/dev/null 2>&1 || true
  sleep 0.5
  FRONTEND_DIST_VAL="$(kv_get FRONTEND_DIST)"; [ -n "$FRONTEND_DIST_VAL" ] || FRONTEND_DIST_VAL="/apps/web/dist"
  SERVE_ROOT="$ROOT_DIR$FRONTEND_DIST_VAL"
  PORT_VAL="$(kv_get FRONTEND_PORT)"; [ -n "$PORT_VAL" ] || PORT_VAL=9081
  if command -v npx >/dev/null 2>&1 && [ -d "$SERVE_ROOT" ]; then
    mkdir -p "$LOG_DIR" 2>/dev/null || true
    echo "----- $(date) front restart on :$PORT_VAL -----" >> "$LOG_DIR/serve.log"
    (cd "$ROOT_DIR" && FRONTEND_MODE=npx nohup npx serve -s "$SERVE_ROOT" -l "$PORT_VAL" >> "$LOG_DIR/serve.log" 2>&1 &)
    ok "frontend restarted on :$PORT_VAL (mode=npx)"
  else
    warn "npx or export missing; backend will serve static files if available"
  fi
}

cmd_front_build(){
  case "${1-}" in -h|--help|help) _help_front_build; return 0;; esac
  banner; section "Frontend build"
  local APP_DIR="$ROOT_DIR/apps/web"
  if [ ! -d "$APP_DIR" ]; then err "apps/web not found"; return 1; fi
  if ! command -v node >/dev/null 2>&1 || ! command -v npx >/dev/null 2>&1; then err "node/npm (npx) not found. Install Node.js."; return 1; fi
  local do_restart=0
  case "${1-}" in --restart|-r) do_restart=1;; esac
  # Stop static server while rebuilding to avoid serving partial files
  section "Stopping static server (if running)"
  pkill -f "(serve -s|npx serve)" >/dev/null 2>&1 || true
  sleep 0.5
  # Install deps if node_modules missing
  if [ ! -d "$APP_DIR/node_modules" ]; then
    section "Installing frontend dependencies (npm ci)"
    (cd "$APP_DIR" && npm ci) || { err "npm ci failed"; return 1; }
  fi
  section "Exporting static web build (expo export)"
  (cd "$APP_DIR" && npx expo export --platform web) || { err "expo export failed"; return 1; }
  # Verify build output exists
  local FRONTEND_DIST_VAL; FRONTEND_DIST_VAL="$(kv_get FRONTEND_DIST)"; [ -n "$FRONTEND_DIST_VAL" ] || FRONTEND_DIST_VAL="/apps/web/dist"
  local SERVE_ROOT="$ROOT_DIR$FRONTEND_DIST_VAL"
  if [ -d "$SERVE_ROOT" ]; then ok "build ready at $FRONTEND_DIST_VAL"; else warn "build output not found at $FRONTEND_DIST_VAL"; fi
  if [ $do_restart -eq 1 ]; then
    cmd_front_restart
  else
    echo "Tip: run 'vibrae front restart' to serve the new build."
  fi
}

cmd_github(){
  local url="https://github.com/danicallero/Vibrae"
  if [[ "$(uname)" == "Darwin" ]]; then open "$url"; echo "Repo: $url"; else xdg-open "$url" 2>/dev/null; echo "Repo: $url" || echo "$url"; fi
}

_resolve_urls(){
  local port domain
  port="$(kv_get FRONTEND_PORT)"; [ -n "$port" ] || port=9081
  domain="$(kv_get DOMAIN)"
  if [ -n "$domain" ]; then
    printf 'PUBLIC_URL=https://%s\n' "$domain"
  fi
  printf 'LOCAL_STATIC=http://127.0.0.1:%s\n' "$port"
  # If nginx listens on 80 we consider it the canonical local entry; else fallback to static
  printf 'LOCAL_CANONICAL=http://127.0.0.1:%s\n' "${NGINX_PORT:-80}"
}
cmd_open(){
  local kvs url
  kvs="$(_resolve_urls)"
  url="$(printf '%s' "$kvs" | awk -F= '/PUBLIC_URL=/{print $2;exit}')"
  if [ -z "$url" ]; then
    url="$(printf '%s' "$kvs" | awk -F= '/LOCAL_STATIC=/{print $2;exit}')"
  fi
  if [[ "$(uname)" == "Darwin" ]]; then
    open "$url"
  else
    xdg-open "$url" 2>/dev/null || echo "$url"
  fi
}
cmd_url(){
  local kvs
  kvs="$(_resolve_urls)"
  echo "$kvs" | sed 's/^/  /'
}

cmd_env_show(){ ensure_env; cat "$ENV_FILE"; }
cmd_env_edit(){ ensure_env; if [[ "$(uname)" == "Darwin" ]] && [ -z "${EDITOR}${VISUAL}" ]; then open -e "$ENV_FILE"; else ${EDITOR:-${VISUAL:-nano}} "$ENV_FILE"; fi }
cmd_env_set(){
  local kv="$1"; if ! echo "$kv" | grep -q '='; then err "usage: vibrae env set KEY=VALUE"; return 1; fi
  local key="${kv%%=*}"; local val="${kv#*=}"; kv_set "$key" "$val"; ok "$key set"
}

# Frontend env command counterparts
cmd_env_f_show(){ ensure_front_env; cat "$FRONT_ENV_FILE"; }
cmd_env_f_edit(){ ensure_front_env; if [[ "$(uname)" == "Darwin" ]] && [ -z "${EDITOR}${VISUAL}" ]; then open -e "$FRONT_ENV_FILE"; else ${EDITOR:-${VISUAL:-nano}} "$FRONT_ENV_FILE"; fi }
cmd_env_f_set(){ local kv="$1"; if ! echo "$kv" | grep -q '='; then err "usage: vibrae env f-set KEY=VALUE"; return 1; fi; local key="${kv%%=*}" val="${kv#*=}"; f_kv_set "$key" "$val"; ok "frontend $key set"; }
cmd_env_f_get(){ ensure_front_env; local k="$1"; [ -z "$k" ] && { err "usage: vibrae env f-get KEY"; return 1; }; f_kv_get "$k" || true; }
cmd_env_f_sync(){ ensure_front_env; local defaults; defaults=$(cat <<'DEFEOF_FE'
EXPO_PUBLIC_API_BASE=/api
DEFEOF_FE
); local added=0; while IFS= read -r line; do [ -z "$line" ] && continue; local key="${line%%=*}" val="${line#*=}"; if ! grep -qE "^${key}=" "$FRONT_ENV_FILE" 2>/dev/null; then echo "${key}=${val}" >> "$FRONT_ENV_FILE"; added=$((added+1)); fi; done <<< "$defaults"; [ $added -gt 0 ] && ok "Frontend env: added $added missing keys" || ok "Frontend env already has recommended keys"; }

env_help(){ _help_env; }

env_get(){ ensure_env; local k="$1"; [ -z "$k" ] && { err "usage: vibrae env get KEY"; return 1; }; kv_get "$k" || true; }

# --- SOPS environment encryption helpers ---
sops_check(){ if ! command -v sops >/dev/null 2>&1; then err "sops not installed (https://github.com/getsops/sops)"; return 1; fi }
sec_dir(){ printf '%s' "$ROOT_DIR/config/env"; }
sec_plain(){ printf '%s' "$(sec_dir)/.env.backend"; }
sec_enc(){ printf '%s' "$(sec_dir)/.env.backend.enc"; }
sec_front_plain(){ printf '%s' "$(sec_dir)/.env.frontend"; }
sec_front_enc(){ printf '%s' "$(sec_dir)/.env.frontend.enc"; }

########################################
## 05 ENCRYPTION (SOPS)
########################################
_sops_run(){ # _sops_run <encrypt|decrypt> <input> <output>
  local mode="$1"; shift; local in="$1"; shift; local out="$1"; shift || true
  local cmd=(sops)
  # Prefer repo config to avoid broken global ~/.sops.yaml issues
  if [ -f "$ROOT_DIR/.sops.yaml" ]; then
    if [ -z "${SOPS_CONFIG:-}" ]; then cmd+=(--config "$ROOT_DIR/.sops.yaml"); fi
  fi
  # Temporarily suppress generic trap noise
  local prev_suppress="${_VIBRAE_SUPPRESS_TRAP:-}"
  _VIBRAE_SUPPRESS_TRAP=1
  case "$mode" in
    encrypt) "${cmd[@]}" --encrypt "$in" > "$out" 2>"$out.err" ;;
    decrypt) "${cmd[@]}" --decrypt "$in" > "$out" 2>"$out.err" ;;
    *) err "_sops_run: invalid mode '$mode'"; return 1;;
  esac
  local rc=$?
  if [ $rc -ne 0 ]; then
    if grep -qi 'unmarshal' "$out.err" 2>/dev/null; then
      err "sops parse error (YAML). Likely a broken global ~/.sops.yaml. Try: mv ~/.sops.yaml ~/.sops.yaml.bak && retry, or export SOPS_CONFIG=./.sops.yaml"
    else
      err "sops $mode failed: $(sed -e 's/\r//g' "$out.err" | tail -n3 | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g')"
    fi
    rm -f "$out.err" 2>/dev/null || true
    # Keep suppression active for this failing path
    return 1
  fi
  # Success path: restore suppression state
  if [ -n "$prev_suppress" ]; then _VIBRAE_SUPPRESS_TRAP="$prev_suppress"; else unset _VIBRAE_SUPPRESS_TRAP; fi
  rm -f "$out.err" 2>/dev/null || true
  return 0
}

cmd_env_encrypt(){ sops_check || return 1; local plain enc; plain="$(sec_plain)"; enc="$(sec_enc)"; [ -f "$plain" ] || { err "plaintext backend env $(basename "$plain") not found"; return 1; }; grep -qE '^[A-Z0-9_]+=.*' "$plain" || { err "refusing to encrypt empty env (no KEY= lines)"; return 1; }; _sops_run encrypt "$plain" "$enc" || return 1; ok "encrypted -> $(basename "$enc") (plaintext kept; DO NOT COMMIT)"; }
cmd_env_decrypt(){ sops_check || return 1; local plain enc; plain="$(sec_plain)"; enc="$(sec_enc)"; if [ ! -f "$enc" ]; then err "encrypted backend file missing: $(basename "$enc")"; return 1; fi; _sops_run decrypt "$enc" "$plain" || return 1; ok "decrypted to $(basename "$plain") (DO NOT COMMIT)"; }
cmd_env_edit_sec(){ sops_check || return 1; local enc plain; enc="$(sec_enc)"; plain="$(sec_plain)"; [ -f "$enc" ] || { err "missing encrypted backend file: $(basename "$enc")"; return 1; }; _sops_run decrypt "$enc" "$plain" || return 1; ${EDITOR:-${VISUAL:-nano}} "$plain"; _sops_run encrypt "$plain" "$enc" || return 1; ok "updated $(basename "$enc") (plaintext retained; DO NOT COMMIT)"; }
cmd_env_f_encrypt(){
  sops_check || return 1
  local plain enc; plain="$(sec_front_plain)"; enc="$(sec_front_enc)"
  if [ ! -f "$plain" ]; then err "plaintext $(basename "$plain") not found"; return 1; fi
  _sops_run encrypt "$plain" "$enc" || return 1
  # Keep plaintext for active development; remind user not to commit.
  ok "encrypted -> $(basename "$enc") (plaintext kept; DO NOT COMMIT)"
}
cmd_env_f_decrypt(){ sops_check || return 1; local plain enc; plain="$(sec_front_plain)"; enc="$(sec_front_enc)"; if [ ! -f "$enc" ]; then err "encrypted file missing: $(basename "$enc")"; return 1; fi; _sops_run decrypt "$enc" "$plain" || return 1; ok "decrypted to $(basename "$plain") (DO NOT COMMIT)"; }
cmd_env_f_edit_sec(){ sops_check || return 1; local enc plain; enc="$(sec_front_enc)"; plain="$(sec_front_plain)"; [ -f "$enc" ] || { err "missing encrypted file: $(basename "$enc")"; return 1; }; _sops_run decrypt "$enc" "$plain" || return 1; ${EDITOR:-${VISUAL:-nano}} "$plain"; _sops_run encrypt "$plain" "$enc" || return 1; ok "updated $(basename "$enc") (plaintext retained; DO NOT COMMIT)"; }

cmd_db_init(){ [ -f "$ROOT_DIR/.installed" ] || { err "setup not run (scripts/app/setup.sh)"; return 1; }; [ -d "$ROOT_DIR/venv" ] || { err "missing venv"; return 1; }; (cd "$ROOT_DIR" && PYTHONPATH="$ROOT_DIR:$(pwd)/packages/core/src" "$ROOT_DIR/venv/bin/python" -m vibrae_core.init_db); ok "database initialized"; }

cmd_env_sync(){ ensure_env; local defaults; defaults=$(cat <<'DEFEOF'
AUTOSTART=false
MUSIC_MODE=folder
MUSIC_DIR=music
USB_SUBDIR=
VIBRAE_MUSIC=
FRONTEND_DIST=/apps/web/dist
# WEB_DIST deprecated; FRONTEND_DIST is canonical
FRONTEND_PORT=9081
BACKEND_PORT=8000
BACKEND_MODULE=apps.api.src.vibrae_api.main:app
SECRET_KEY=change-me-please
LOG_LEVEL=INFO
LOG_KEEP=5
LOG_ROTATE_INTERVAL_HOURS=12
DOMAIN=
NGINX_CONF=nginx.conf
TUNNEL=cloudflared
CLOUDFLARE_TUNNEL_TOKEN=
DEFEOF
); local added=0; while IFS= read -r line; do [ -z "$line" ] && continue; local key="${line%%=*}" val="${line#*=}"; if ! grep -qE "^${key}=" "$ENV_FILE" 2>/dev/null; then echo "${key}=${val}" >> "$ENV_FILE"; added=$((added+1)); fi; done <<< "$defaults"; [ $added -gt 0 ] && ok "Added $added missing keys" || ok ".env already has recommended keys"; }

cmd_autostart(){
  case "$1" in
    on)
      kv_set AUTOSTART true
      ok "AUTOSTART=true"
      # Re-encrypt backend env so .enc stays current
      if command -v sops >/dev/null 2>&1; then
        cmd_env_encrypt || warn "re-encrypt failed; run 'vibrae env encrypt' manually"
      else
        warn "sops not installed; skipping re-encrypt"
      fi
      ;;
    off)
      kv_set AUTOSTART false
      ok "AUTOSTART=false"
      if command -v sops >/dev/null 2>&1; then
        cmd_env_encrypt || warn "re-encrypt failed; run 'vibrae env encrypt' manually"
      else
        warn "sops not installed; skipping re-encrypt"
      fi
      ;;
    *)
      err "usage: vibrae autostart on|off"
      return 1
      ;;
  esac
}

cmd_source_detect(){
  ensure_env
  local mode dir label
  mode="$(kv_get MUSIC_SOURCE_MODE)"; [ -n "$mode" ] || mode="$(kv_get MUSIC_MODE)"; [ -n "$mode" ] || mode="folder"
  dir="$(kv_get MUSIC_DIR)"; [ -n "$dir" ] || dir="music"
  label="$(kv_get VIBRAE_MUSIC)"; [ -n "$label" ] || label="$(kv_get USB_VOLUME_LABEL)"

  if [ -z "$label" ] && [ "$mode" = "usb" ]; then
    warn "VIBRAE_MUSIC not set (USB volume label). USB_VOLUME_LABEL is deprecated; set VIBRAE_MUSIC instead."
  fi
  if [ "$mode" = "usb" ]; then
    [ -n "$label" ] && echo "usb:$label" || echo "usb:(no label)"
  else
    echo "folder:$dir"
  fi
}

cmd_check_env(){ banner; ensure_env; local ENC_FILE="${ENV_FILE}.enc"; if [ -f "$ENC_FILE" ]; then if [ ! -f "$ENV_FILE" ]; then warn "cannot validate keys until you decrypt the backend env"; echo "Run: vibrae env decrypt"; return 2; fi; if [ "$ENC_FILE" -nt "$ENV_FILE" ]; then warn "encrypted backend env is newer than plaintext; run: vibrae env decrypt"; else ok "encrypted backend env detected (plaintext appears current)"; fi; fi; local issues=0; _VIBRAE_SUPPRESS_TRAP=1; check(){ local k="$1" msg="$2" v; v="$(kv_get "$k" || true)"; if [ -z "${v}" ]; then issues=$((issues+1)); printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "$k" "$msg"; fi; }; check SECRET_KEY "JWT signing secret is required"; check BACKEND_PORT "defaults to 8000 if unset"; check FRONTEND_PORT "defaults to 9081 if unset"; check FRONTEND_DIST "path to exported web (default /apps/web/dist)"; local mode; mode="$(kv_get MUSIC_MODE || true)"; [ -z "$mode" ] && mode="$(kv_get MUSIC_SOURCE_MODE || true)"; if [ -z "$mode" ]; then printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "MUSIC_MODE" "folder|usb (default folder)"; issues=$((issues+1)); fi; if [ "$mode" = "usb" ]; then local label; label="$(kv_get USB_VOLUME_LABEL || true)"; [ -z "$label" ] && label="$(kv_get VIBRAE_MUSIC || true)"; [ -z "$label" ] && printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "VIBRAE_MUSIC" "USB volume label or absolute mount path"; fi; local tunnel; tunnel="$(kv_get TUNNEL || true)"; [ -z "$tunnel" ] && tunnel="cloudflared"; if [ "$tunnel" = "cloudflared" ]; then local tok; tok="$(kv_get CLOUDFLARE_TUNNEL_TOKEN || true)"; [ -z "$tok" ] && printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "CLOUDFLARE_TUNNEL_TOKEN" "required when TUNNEL=cloudflared"; fi; unset _VIBRAE_SUPPRESS_TRAP; [ $issues -eq 0 ] && ok "env looks good" || warn "$issues item(s) to review"; }

cmd_doctor(){ banner; hdr "Tools"; command -v python3 >/dev/null && ok "python3" || err "python3 MISSING"; command -v pip >/dev/null && ok "pip" || err "pip MISSING"; command -v node >/dev/null && ok "node" || warn "node not found (frontend optional)"; command -v npm >/dev/null && ok "npm" || warn "npm not found (frontend optional)"; command -v nginx >/dev/null && ok "nginx" || warn "nginx not found (reverse proxy optional)"; command -v cloudflared >/dev/null && ok "cloudflared" || warn "cloudflared not found (public URL optional)"; if [[ "$(uname)" == "Darwin" ]]; then command -v brew >/dev/null && ok "brew" || warn "brew not found (auto-install skipped)"; fi; hdr "Python"; if [ -d "$ROOT_DIR/venv" ]; then "$ROOT_DIR/venv/bin/python" - <<'PY'
import sys, os
USE_COLOR = sys.stdout.isatty() and os.environ.get("NO_COLOR") is None
def color(code, s):
  return f"\033[{code}m{s}\033[0m" if USE_COLOR else s
def ok(msg):
  print(f"{color('32','[ok]')} {msg}")
def warn(msg):
  print(f"{color('33','[warn]')} {msg}")
mods=["fastapi","uvicorn","sqlalchemy","pydantic","jose","python_dotenv","websockets","vlc"]
missing=[]
for m in mods:
  try:
    __import__(m)
  except Exception:
    missing.append(m)
if missing:
  warn("missing modules: " + ", ".join(missing))
else:
  ok("Python deps present")
try:
  import vlc
  try:
    _=vlc.Instance()
    ok("libVLC available")
  except Exception:
    warn("libVLC not available; install VLC media player")
except Exception:
  pass
PY
  else warn "venv not found; run scripts/app/setup.sh"; fi }


########################################
## 06 PI HELPERS
########################################
is_pi(){ [ -f /etc/raspberrypi-release ] || grep -qi 'raspberry' /proc/cpuinfo 2>/dev/null || grep -qi 'raspi' /proc/cpuinfo 2>/dev/null; }
cmd_pi_install(){
  license_notice
  if ! is_pi; then warn "Not a Raspberry Pi (continuing anyway)"; fi
  # Support optional flag: --sudoers|-S to enable passwordless sudo for Vibrae ops
  local sudoers_flag=""
  case "${1-}" in
    --sudoers|-S) sudoers_flag=1; shift || true;;
  esac
  if [ -n "$sudoers_flag" ]; then
    VIBRAE_SUDOERS=1 sudo -E bash "$ROOT_DIR/scripts/pi/setup.sh" | colorize_stream
  else
    sudo -E bash "$ROOT_DIR/scripts/pi/setup.sh" | colorize_stream
  fi
}
cmd_pi_start(){ license_notice; [ -f "$ROOT_DIR/.installed" ] || warn "setup has not been run locally; proceeding with Pi systemd start"; sudo bash "$ROOT_DIR/scripts/pi/run.sh" | colorize_stream; }
cmd_pi_stop(){ license_notice; sudo bash "$ROOT_DIR/scripts/pi/stop.sh" | colorize_stream; }
cmd_pi_status(){ banner; sudo systemctl --no-pager status vibrae-backend vibrae-frontend vibrae-cloudflared nginx || true; }
cmd_pi_logs(){ local unit="${1:-vibrae-backend}"; sudo journalctl -u "$unit" -f; }

# Enable extended glob for trimming
shopt -s extglob 2>/dev/null || true

########################################
## 07 INTERACTIVE SHELL
########################################
run_interactive(){ banner; autostart_maybe_start || true; printf "Type 'help' for commands, 'quit' to exit.\n"; while true; do if read -e -r -p "vibrae> " line; then line="${line##+([[:space:]])}"; line="${line%%+([[:space:]])}"; case "$line" in "" ) continue ;; quit|exit ) break ;; help ) usage; echo; continue ;; clear ) clear 2>/dev/null || printf '\033c'; echo; continue ;; esac; IFS=' ' read -r -a args <<< "$line"; set +e; dispatch "${args[@]}"; rc=$?; set -e; echo; else break; fi; done }

########################################
## 08 DISPATCH
########################################
_COMMANDS=""
_register(){ # name function description
  _COMMANDS="$_COMMANDS
$1|$2|$3"; }
_find_fn(){ printf '%s' "$_COMMANDS" | awk -F'|' -v C="$1" 'NF>=2 && $1==C {print $2; exit}'; }
_is_registered(){
  # awk exits 0 even when no match; ensure the output is non-empty
  local fn
  fn="$(_find_fn "$1")"
  if [ -n "$fn" ]; then
    return 0
  else
    return 1
  fi
}
# List unique primary commands only (dedupe aliases)
# We consider the first occurrence of a function as the primary entry
## Unused helpers removed: _list_commands and _list_commands_by_category

# Register primary commands
_register version    cmd_version        "Show CLI version"
_register install    cmd_install        "Install/update dependencies"
_register start      cmd_start          "Start all services"
_register up         cmd_start          "Alias for start"
_register stop       cmd_stop           "Stop all services"
_register down       cmd_stop           "Alias for stop"
_register restart    cmd_restart        "Restart services"
_register status     cmd_status         "Show service status"
_register st         cmd_status         "Alias for status"
_register logs       cmd_logs           "Tail logs"
_register front-restart cmd_front_restart "Restart static frontend server"
_register front       cmd_front_root     "Frontend operations"
_register front-build cmd_front_build    "Build/export static frontend"
_register open       cmd_open           "Open primary URL"
_register url        cmd_url            "Print URLs"
_register contact    contact_information "Contact info"
_register github     cmd_github         "Open GitHub repository"
_register env        cmd_env_root       "Environment subcommands"
_register db-init    cmd_db_init        "Initialize database"
_register autostart  cmd_autostart      "Toggle autostart"
_register source-detect cmd_source_detect "Detect music source"
_register check-env  cmd_check_env      "Validate environment"
_register ce         cmd_check_env      "Alias for check-env"
_register doctor     cmd_doctor         "Doctor diagnostics"
_register doc        cmd_doctor         "Alias for doctor"
_register shell      run_interactive    "Interactive shell"
_register sh         run_interactive    "Alias for shell"
_register ahelp      cmd_alias_help     "Show alias help"
_register systemd    cmd_pi_root        "Systemd (Linux) helpers"
_register sys        cmd_pi_root        "Alias for systemd helpers"
_register pi         cmd_pi_root        "Alias for systemd helpers"
_register mac        cmd_mac_root       "macOS helpers"
_register help       cmd_help           "Show help"
_register --help     cmd_help           "Show help"
_register -h         cmd_help           "Show help"
_register ls-env     cmd_env_show       "Alias for env show"

cmd_version(){ echo "vibrae ${VERSION}"; }
_help_version(){ help_banner; section "Version"; echo "  vibrae $VERSION"; }
cmd_env_root(){
  case "${1-}" in
    -h|--help|help) _help_env; return 0;;
    show|ls|cat) shift; cmd_env_show;;
    edit) shift; cmd_env_edit;;
    encrypt) shift; cmd_env_encrypt;;
    decrypt) shift; cmd_env_decrypt;;
    edit-sec) shift; cmd_env_edit_sec;;
    f-encrypt) shift; cmd_env_f_encrypt;;
    f-decrypt) shift; cmd_env_f_decrypt;;
    f-edit-sec) shift; cmd_env_f_edit_sec;;
  f-show|f-cat) shift; cmd_env_f_show;;
  f-edit) shift; cmd_env_f_edit;;
  f-set) shift; cmd_env_f_set "$@";;
  f-get) shift; cmd_env_f_get "$@";;
  f-sync) shift; cmd_env_f_sync;;
    set) shift; cmd_env_set "$@";;
    get) shift; env_get "$@";;
    sync) shift; cmd_env_sync;;
    help) shift; _help_env;;
    *) err "env: unknown subcommand '${1-}'"; env_help; return 1;;
  esac
}
_help_env(){
  help_banner
  section "Backend Environment"
  echo "  Usage: vibrae env <subcommand> [args]"; echo
  echo "  Subcommands:"; cat <<EOC
    show|ls|cat        Print backend env (.env.backend)
    edit               Open env file in editor
    set KEY=VALUE      Add or replace a key
    get KEY            Print single value (empty if unset)
    sync               Append missing recommended keys (non-destructive)
    encrypt            Encrypt backend env -> .env.backend.enc
    decrypt            Decrypt encrypted backend env to plaintext
    edit-sec           Decrypt, open editor, re-encrypt
EOC
    section "Frontend Environment"
    echo "  Usage: vibrae env <subcommand> [args]"; echo
    echo "  Subcommands:"; cat <<EOC
    f-show|f-cat       Print frontend env (.env.frontend)
    f-edit             Open frontend env file
    f-set KEY=VALUE    Set/add a frontend key
    f-get KEY          Print frontend single value
    f-sync             Append missing recommended frontend keys
    f-encrypt          Encrypt frontend env
    f-decrypt          Decrypt frontend env
    f-edit-sec         Decrypt, edit, re-encrypt frontend env

EOC
  echo "Notes:"; cat <<'EOC'
    - Never commit plaintext env files
    - If only .enc exists run: vibrae env decrypt
    - sync will NOT overwrite existing values
    - Use edit-sec for safe secret changes
EOC
}
cmd_pi_sudoers(){
  banner; section "Pi sudoers"
  local user="$USER"
  local sudoers_file="/etc/sudoers.d/vibrae-$user"
  local SYSTEMCTL_PATH JOURNALCTL_PATH
  SYSTEMCTL_PATH="$(command -v systemctl || echo /bin/systemctl)"
  JOURNALCTL_PATH="$(command -v journalctl || echo /bin/journalctl)"
  local tmp; tmp="$(mktemp 2>/dev/null || echo "/tmp/vibrae_pi_sudoers_${user}.$$")"
  cat > "$tmp" <<SUDO
Cmnd_Alias VIBRAE_CMDS = \
  $SYSTEMCTL_PATH start vibrae-*, \
  $SYSTEMCTL_PATH stop vibrae-*, \
  $SYSTEMCTL_PATH restart vibrae-*, \
  $SYSTEMCTL_PATH status vibrae-*, \
  $SYSTEMCTL_PATH start nginx, \
  $SYSTEMCTL_PATH stop nginx, \
  $SYSTEMCTL_PATH restart nginx, \
  $SYSTEMCTL_PATH status nginx, \
  $JOURNALCTL_PATH -u vibrae-*, \
  $JOURNALCTL_PATH -u nginx, \
  /bin/bash $ROOT_DIR/scripts/pi/setup.sh, \
  /bin/bash $ROOT_DIR/scripts/pi/run.sh, \
  /bin/bash $ROOT_DIR/scripts/pi/stop.sh
$user ALL=(root) NOPASSWD: VIBRAE_CMDS
SUDO
  echo "Installing sudoers file: $sudoers_file"
  if ! sudo install -m 440 "$tmp" "$sudoers_file"; then
    err "failed to install sudoers file"
    rm -f "$tmp" 2>/dev/null || true
    return 1
  fi
  rm -f "$tmp" 2>/dev/null || true
  ok "sudoers installed for user $user"
}
cmd_pi_root(){ case "${1-}" in -h|--help|help|'') _help_pi; return 0;; install) shift; cmd_pi_install "$@";; start) shift; cmd_pi_start "$@";; stop) shift; cmd_pi_stop "$@";; status) shift; cmd_pi_status "$@";; logs) shift; cmd_pi_logs "$@";; sudoers) shift; cmd_pi_sudoers "$@";; *) err "systemd: unknown subcommand '${1-}'"; return 1;; esac }
_help_pi(){ help_banner; section "Systemd (Linux)"; cat <<'HPI'
  Usage: vibrae systemd <install|start|stop|status|logs|sudoers> [options]
         (aliases: sys, pi)

  install [--sudoers|-S]  Configure systemd + nginx on Linux
                          --sudoers adds a limited passwordless sudoers rule
  start                   Start services via systemd (sudo)
  stop                    Stop services (sudo)
  status                  Systemd status summary (sudo)
  logs [unit]             Follow journal for unit (sudo; default vibrae-backend)
  sudoers                 Add NOPASSWD rule without reinstalling

Notes:
  - 'systemd install' preserves env via sudo -E, so AGE/GPG/GIT_SSH_* can be passed.
  - Enable passwordless sudo later by re-running: vibrae systemd install --sudoers
  - Or run independently anytime: vibrae systemd sudoers
HPI
}

########################################
## 07b MAC HELPERS
########################################
cmd_mac_sudoers(){
  banner; section "macOS sudoers"
  if [[ "$(uname)" != "Darwin" ]]; then warn "This helper is intended for macOS"; fi
  local user="$USER"
  local nginx_bin pkill_bin ctl_script sudoers_file
  nginx_bin="$(command -v nginx || echo /usr/local/bin/nginx)"
  pkill_bin="$(command -v pkill || echo /usr/bin/pkill)"
  ctl_script="$ROOT_DIR/scripts/nginxctl.sh"
  sudoers_file="/etc/sudoers.d/vibrae-${user}"
  if [ ! -x "$nginx_bin" ]; then warn "nginx not found; install via Homebrew (brew install nginx)"; fi
  section "Writing sudoers entry (requires admin)"
  local tmp; tmp="$(mktemp 2>/dev/null || echo "/tmp/vibrae_sudoers_${user}.$$")"
  cat >"$tmp" <<SUDO
Cmnd_Alias VIBRAE_MAC = \
  $nginx_bin, \
  $pkill_bin, \
  /bin/bash $ctl_script
$user ALL=(root) NOPASSWD: VIBRAE_MAC
SUDO
  echo "Creating $sudoers_file"
  if ! sudo install -m 440 "$tmp" "$sudoers_file"; then
    err "failed to write sudoers"
    rm -f "$tmp" 2>/dev/null || true
    return 1
  fi
  rm -f "$tmp" 2>/dev/null || true
  ok "sudoers installed: $sudoers_file"
  echo "Notes:"
  echo "  - Grants NOPASSWD for nginx, pkill, and nginxctl.sh (limited to this repo path)."
  echo "  - If your repo path changes, re-run: vibrae mac sudoers"
}
cmd_mac_root(){ case "${1-}" in -h|--help|help) _help_mac; return 0;; sudoers) shift; cmd_mac_sudoers "$@";; *) err "mac: unknown subcommand '${1-}'"; return 1;; esac }
_help_mac(){ help_banner; section "macOS"; cat <<'HMAC'
  Usage: vibrae mac <sudoers>

  sudoers    Install a limited NOPASSWD sudoers rule to control nginx
             and the helper script without re-entering your password.

Notes:
  - Applies to nginx start/stop (via nginx or nginxctl.sh) and pkill for cleanup.
  - On macOS, binding to :80 requires elevated privileges; this avoids prompts.
HMAC
}
cmd_alias_help(){ echo "Aliases:"; echo "  up->start down->stop st->status ce->check-env doc->doctor sh->shell"; }
_help_start(){ help_banner; section "Start"; cat <<'HSTART'
  Usage: vibrae start

  Starts backend (uvicorn), static server (if export present), and tunnel if configured.
  Equivalent alias: up
  Fails if setup not completed (missing .installed or venv).
HSTART
}
_help_logs(){ help_banner; section "Logs"; cat <<'HLOGS'
  Usage: vibrae logs [name] [n]

  name: backend|player|serve|cloudflared (default: all)
  n:    number of lines (default 100)

  Examples:
    vibrae logs
    vibrae logs backend 200
HLOGS
}
_help_front_restart(){ help_banner; section "Front Restart"; cat <<'HFR'
  Usage: vibrae front restart

  Restarts only the static file server (npx serve) if available.
  Does NOT restart backend services.
HFR
}
cmd_front_root(){
  case "${1-}" in
    -h|--help|help|'') _help_front; return 0;;
  restart) shift; cmd_front_restart "$@";;
  build|export|rebuild) shift; cmd_front_build "$@";;
    *) err "front: unknown subcommand '${1-}'"; _help_front; return 1;;
  esac
}
_help_front(){ help_banner; section "Frontend"; cat <<'HF'
  Usage: vibrae front <subcommand>

  Subcommands:
    restart            Restart static server (npx serve) only
  build|export       Rebuild static web (Expo export)

  Notes:
    - Not for env operations (use: vibrae env ...)
    - Falls back to backend static serving if npx serve missing
  - Use 'vibrae front build --restart' to rebuild and restart in one step
HF
}
_help_front_build(){ help_banner; section "Front Build"; cat <<'HFB'
  Usage: vibrae front build [--restart|-r]

  Runs Expo web export in apps/web:
  - Stops the static server during the build (if running)
    - Installs dependencies (npm ci) if node_modules is missing
    - Executes: npx expo export --platform web
    - Places output at FRONTEND_DIST (default /apps/web/dist)

  Options:
    --restart, -r   After building, restart the static server (same as 'vibrae front restart')
HFB
}
cmd_help(){ usage; }
_show_cmd_help(){ HELP_BANNER_SHOWN=""; local c="$1"; local helper="_help_${c//-/_}"; if command -v "$helper" >/dev/null 2>&1; then "$helper"; else err "No detailed help for '$c'"; fi }

dispatch(){
  local cmd="${1-}"
  if [ -z "$cmd" ]; then
    if [ ! -f "$ROOT_DIR/.installed" ] || [ ! -d "$ROOT_DIR/venv" ]; then onboarding_message; return 0; else run_interactive; return 0; fi
  fi
  # Map 'restart -front' or 'restart front' to frontend-only restart
  if [ "$cmd" = "restart" ] && { [ "${2-}" = "-front" ] || [ "${2-}" = "front" ]; }; then
    cmd="front"
    # Preserve any additional flags (e.g., -h) when remapping
    set -- front restart "${@:3}"
  fi
  # Map db init -> db-init
  if [ "$cmd" = "db" ] && [ "${2-}" = "init" ]; then shift; cmd="db-init"; shift || true; fi
  # Source detect -> source-detect
  if [ "$cmd" = "source" ] && [ "${2-}" = "detect" ]; then shift; cmd="source-detect"; shift || true; fi
  if ! _is_registered "$cmd"; then err "Unknown command: $cmd"; echo "Run 'vibrae help' for list."; return 1; fi
  shift || true
  local fn; fn="$(_find_fn "$cmd")"
  if [ -z "$fn" ]; then err "internal dispatch error ($cmd)"; return 2; fi
  case "$cmd" in env|pi|front) "$fn" "$@"; return $?;; esac
  case "${1-}" in -h|--help|help) _show_cmd_help "$cmd"; return 0;; esac
  "$fn" "$@"
  return $?
}

########################################
## 09 MAIN
########################################
main(){ _VIBRAE_TRAP_READY=1; export _VIBRAE_TRAP_READY; unset _VIBRAE_SUPPRESS_TRAP 2>/dev/null || true; dispatch "$@"; rc=$?; return $rc; }

# Enable -u late to avoid early false ERR triggers
if [ -n "${DEFER_SET_U:-}" ]; then
  set -u
  unset DEFER_SET_U
fi

main "$@"; exit $?
