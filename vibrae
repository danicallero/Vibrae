#!/bin/bash
# SPDX-License-Identifier: GPL-3.0-or-later
# Vibrae CLI: install, run, inspect.
# Usage: vibrae <command> [args]

set -Eeuo pipefail
IFS=$'\n\t'

VERSION="0.4.1"

trap 'err "unexpected error (line ${LINENO})"' ERR

# Resolve script directory robustly even when invoked via symlink (e.g., /usr/local/bin/vibrae)
resolve_self(){
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir; dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  printf '%s' "$src"
}
SCRIPT_PATH="$(resolve_self)"
ROOT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
ENV_FILE="$ROOT_DIR/.env"
ENV_EXAMPLE="$ROOT_DIR/.env.example"
LOG_DIR="$ROOT_DIR/logs"

# colors (respect NO_COLOR and non-TTY)
if [ -z "${NO_COLOR:-}" ] && [ -t 1 ] && command -v tput >/dev/null 2>&1 && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
  BOLD="$(tput bold)"; RESET="$(tput sgr0)"
  RED="$(tput setaf 1)"; GREEN="$(tput setaf 2)"; YELLOW="$(tput setaf 3)"; BLUE="$(tput setaf 4)"; GREY="$(tput setaf 8)"
else BOLD=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; GREY=""; fi
ok(){ printf "%b✔%b %s\n" "$GREEN" "$RESET" "$*"; }
warn(){ printf "%b!%b %s\n" "$YELLOW" "$RESET" "$*"; }
err(){ printf "%bx%b %s\n" "$RED" "$RESET" "$*" 1>&2; }
hdr(){ printf "%b%s%b\n" "$BOLD" "$*" "$RESET"; }

banner(){ printf "=== %bVibrae%b — sound, simplified ===\n" "$BOLD" "$RESET"; }

license_notice(){ printf "%bVibrae%b (GPLv3, no warranty)\n" "$BOLD" "$RESET"; }

contact_information(){
  printf "%bContact%b\n" "$BOLD" "$RESET"
  printf "Issues: GitHub repo (vibrae). Email: vibrae@danicallero.es\n"
}

usage(){
  banner
  cat <<EOF

${BOLD}Core${RESET}
  ${BOLD}version${RESET}              Show CLI version
  ${BOLD}install${RESET}              Install/update dependencies (setup.sh)
  ${BOLD}start${RESET} | up          Start all services (run.sh)
  ${BOLD}stop${RESET} | down         Stop all services (stop.sh)
  ${BOLD}restart${RESET}             Stop then start
  ${BOLD}status${RESET}              Show service status (process + health)
  ${BOLD}logs${RESET} [name] [n]     Tail logs (backend|player|serve|cloudflared). Default all; n=100
  ${BOLD}front restart${RESET}        Restart only static server
  ${BOLD}open${RESET}                Open web UI
  ${BOLD}url${RESET}                 Print local/public URLs

${BOLD}Environment & Secrets${RESET}
  ${BOLD}env show${RESET}            Print .env
  ${BOLD}env edit${RESET}            Edit .env
  ${BOLD}env set${RESET} KEY=VALUE   Set or add a key
  ${BOLD}env sync${RESET}            Add any missing recommended keys
  ${BOLD}env encrypt${RESET}         Encrypt runtime env (SOPS)
  ${BOLD}env decrypt${RESET}         Decrypt runtime env
  ${BOLD}env edit-sec${RESET}        Decrypt, edit, re-encrypt

${BOLD}Database${RESET}
  ${BOLD}db init${RESET}             Create tables & seed admin (if absent)

${BOLD}Music Source${RESET}
  ${BOLD}source detect${RESET}       Show resolved source (folder:/path or usb:LABEL)
  ${BOLD}autostart${RESET} on|off    Toggle AUTOSTART (auto start on shell entry)

${BOLD}Diagnostics${RESET}
  ${BOLD}check-env${RESET}           Validate .env values
  ${BOLD}doctor${RESET}              Check required tools & deps

${BOLD}Raspberry Pi${RESET}
  ${BOLD}pi install${RESET}          Pi setup (systemd, nginx)
  ${BOLD}pi start|stop|status${RESET} Manage Pi services
  ${BOLD}pi logs${RESET} [unit]      Tail journal for a unit

${BOLD}Misc${RESET}
  ${BOLD}shell${RESET}               Interactive shell
  ${BOLD}clear${RESET}               Clear the screen
  ${BOLD}help${RESET}                Show this help

EOF
}

ensure_env(){ [ -f "$ENV_FILE" ] || { echo "# Vibrae environment" > "$ENV_FILE"; }; }

run_script(){
  local script="$1"
  if [ ! -x "$ROOT_DIR/$script" ] && [ -f "$ROOT_DIR/$script" ]; then chmod +x "$ROOT_DIR/$script" || true; fi
  if [ ! -f "$ROOT_DIR/$script" ]; then err "script not found: $script"; return 1; fi
  (cd "$ROOT_DIR" && ./"$script")
}

kv_set(){
  local key="$1"; local val="$2"
  ensure_env
  local tmp
  tmp="$(mktemp 2>/dev/null || true)"
  if [ -z "$tmp" ]; then tmp="${ENV_FILE}.tmp.$$"; fi
  awk -v K="$key" -v V="$val" '
    BEGIN{ set=0 }
    /^[#[:space:]]/ { print; next }
    $0 ~ "^"K"=" { if(!set){ print K"="V; set=1 } ; next }
    { print }
    END{ if(!set) print K"="V }
  ' "$ENV_FILE" > "$tmp" && mv "$tmp" "$ENV_FILE"
}
kv_get(){ local key="$1"; [ -f "$ENV_FILE" ] || return 1; grep -E "^${key}=" "$ENV_FILE" | head -n1 | sed -E "s/^${key}=//"; }

# helpers
truthy(){ case "$(echo "$1" | tr '[:upper:]' '[:lower:]')" in true|1|yes|on) return 0;; *) return 1;; esac }
is_uvicorn_running(){ pgrep -f "uvicorn" >/dev/null 2>&1; }

autostart_maybe_start(){
  ensure_env
  local as; as="$(kv_get AUTOSTART)"
  if truthy "$as"; then
    if is_uvicorn_running; then
      ok "AUTOSTART on; already running"
    else
      if [ ! -f "$ROOT_DIR/.installed" ] || [ ! -d "$ROOT_DIR/venv" ]; then
        warn "AUTOSTART on but setup not completed; run ./setup.sh first"
      else
        warn "AUTOSTART on; starting services"
        cmd_start
      fi
    fi
    return 0
  fi
  return 1
}

cmd_install(){ run_script setup.sh; }
cmd_start(){
  # Require install stamp and venv
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup has not been run. Run: ./setup.sh or 'vibrae install'"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv. Run: ./setup.sh"; return 1; fi
  run_script run.sh;
}
cmd_stop(){ run_script stop.sh; }
cmd_restart(){
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup has not been run. Run: ./setup.sh or 'vibrae install'"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv. Run: ./setup.sh"; return 1; fi
  license_notice; cmd_stop || true; cmd_start;
}

service_row(){
  local name="$1"; local patt="$2"; local psout="$3"
  if echo "$psout" | grep -E "$patt" | grep -v grep >/dev/null; then
    printf "  %b●%b %-12s %brunning%b\n" "$GREEN" "$RESET" "$name" "$GREEN" "$RESET"
  else
    printf "  %b○%b %-12s %bstopped%b\n" "$GREY" "$RESET" "$name" "$GREY" "$RESET"
  fi
}
cmd_status(){
  banner
  local psout; psout="$(/bin/ps aux || ps -ef || true)"
  hdr "Services"; service_row "uvicorn" "uvicorn" "$psout"; service_row "static-serve" "(serve -s|npx serve)" "$psout"; service_row "cloudflared" "cloudflared" "$psout"
  # Frontend mode detection
  local mode="backend"
  if echo "$psout" | grep -E "(serve -s|npx serve)" >/dev/null; then mode="npx"; fi
  printf "\nFrontend: %s\n" "$mode"
  # health via backend
  local api_url="http://127.0.0.1/api/health"
  local json; json="$(curl -s "$api_url" || echo '')"
  if [ -n "$json" ]; then
    local backend fe fe_mode player proxy cf fe_srv
    backend=$(echo "$json" | sed -n 's/.*"backend"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    fe=$(echo "$json" | sed -n 's/.*"frontend"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    fe_mode=$(echo "$json" | sed -n 's/.*"frontend_mode"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    player=$(echo "$json" | sed -n 's/.*"player"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    proxy=$(echo "$json" | sed -n 's/.*"proxy"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    cf=$(echo "$json" | sed -n 's/.*"cloudflared"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    fe_srv=$(echo "$json" | sed -n 's/.*"frontend_server"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    printf "\nHealth\n"
    printf "  backend:   %s\n" "${backend:-unknown}"
    printf "  player:    %s\n" "${player:-unknown}"
    printf "  frontend:  %s (mode=%s, static=%s)\n" "${fe:-unknown}" "${fe_mode:-auto}" "${fe_srv:-down}"
    printf "  proxy:     %s\n" "${proxy:-unknown}"
    printf "  tunnel:    %s\n" "${cf:-unknown}"
  else
    printf "API (/api/health): unreachable\n"
  fi
}

cmd_logs(){
  mkdir -p "$LOG_DIR" 2>/dev/null || true
  local name="$1"; shift || true
  local lines="${1:-100}"
  if [ -z "$name" ]; then
    for f in backend player serve cloudflared; do
      hdr "$f.log"; tail -n "$lines" "$LOG_DIR/$f.log" 2>/dev/null || warn "no $f.log"; echo
    done
  else
    hdr "$name.log"; tail -n "$lines" "$LOG_DIR/$name.log" 2>/dev/null || err "no such log: $name"
  fi
}

cmd_front_restart(){
  # Restart only the npx static server
  banner
  hdr "Frontend restart"
  pkill -f "(serve -s|npx serve)" >/dev/null 2>&1 || true
  sleep 0.5
  # Re-run the portion from run.sh that starts npx if possible
  FRONTEND_DIST_VAL="$(kv_get FRONTEND_DIST)"; [ -n "$FRONTEND_DIST_VAL" ] || FRONTEND_DIST_VAL="/apps/web/dist"
  SERVE_ROOT="$ROOT_DIR$FRONTEND_DIST_VAL"
  PORT_VAL="$(kv_get FRONTEND_PORT)"; [ -n "$PORT_VAL" ] || PORT_VAL=9081
  if command -v npx >/dev/null 2>&1 && [ -d "$SERVE_ROOT" ]; then
    mkdir -p "$LOG_DIR" 2>/dev/null || true
    echo "----- $(date) front restart on :$PORT_VAL -----" >> "$LOG_DIR/serve.log"
    (cd "$ROOT_DIR" && FRONTEND_MODE=npx nohup npx serve -s "$SERVE_ROOT" -l "$PORT_VAL" >> "$LOG_DIR/serve.log" 2>&1 &)
    ok "frontend restarted on :$PORT_VAL (mode=npx)"
  else
    warn "npx or export missing; backend will serve static files if available"
  fi
}

cmd_github(){
  local url="https://github.com/danicallero/Vibrae"
  if [[ "$(uname)" == "Darwin" ]]; then open "$url"; echo "Repo: $url"; else xdg-open "$url" 2>/dev/null; echo "Repo: $url" || echo "$url"; fi
}

cmd_open(){
  local domain; domain="$(kv_get DOMAIN)"
  local port; port="$(kv_get FRONTEND_PORT)"; [ -n "$port" ] || port=9081
  local url
  if [ -n "$domain" ]; then url="https://$domain"; else url="http://127.0.0.1:80"; fi
  if [[ "$(uname)" == "Darwin" ]]; then open "$url"; else xdg-open "$url" 2>/dev/null || echo "$url"; fi
}
cmd_url(){
  local port; port="$(kv_get FRONTEND_PORT)"; [ -n "$port" ] || port=9081
  echo "Local (nginx):  http://127.0.0.1"
  echo "Local (static): http://127.0.0.1:$port"
  local domain; domain="$(kv_get DOMAIN)"; [ -n "$domain" ] && echo "Public: https://$domain"
}

cmd_env_show(){ ensure_env; cat "$ENV_FILE"; }
cmd_env_edit(){ ensure_env; if [[ "$(uname)" == "Darwin" ]] && [ -z "${EDITOR}${VISUAL}" ]; then open -e "$ENV_FILE"; else ${EDITOR:-${VISUAL:-nano}} "$ENV_FILE"; fi }
cmd_env_set(){
  local kv="$1"; if ! echo "$kv" | grep -q '='; then err "usage: vibrae env set KEY=VALUE"; return 1; fi
  local key="${kv%%=*}"; local val="${kv#*=}"; kv_set "$key" "$val"; ok "$key set"
}

# --- SOPS environment encryption helpers ---
sops_check(){ if ! command -v sops >/dev/null 2>&1; then err "sops not installed (https://github.com/getsops/sops)"; return 1; fi }
sec_dir(){ printf '%s' "$ROOT_DIR/config/env"; }
sec_plain(){ printf '%s/.env.runtime' "$(sec_dir)"; }
sec_enc(){ printf '%s/.env.runtime.enc' "$(sec_dir)"; }

cmd_env_encrypt(){ sops_check || return 1; local plain enc; plain="$(sec_plain)"; enc="$(sec_enc)"; if [ ! -f "$plain" ]; then err "plaintext $(basename "$plain") not found"; return 1; fi; sops --encrypt "$plain" > "$enc" || return 1; shred -u "$plain" 2>/dev/null || rm -f "$plain"; ok "encrypted -> $(basename "$enc")"; }
cmd_env_decrypt(){ sops_check || return 1; local plain enc; plain="$(sec_plain)"; enc="$(sec_enc)"; if [ ! -f "$enc" ]; then err "encrypted file missing: $(basename "$enc")"; return 1; fi; sops --decrypt "$enc" > "$plain" || return 1; ok "decrypted to $(basename "$plain") (DO NOT COMMIT)"; }
cmd_env_edit_sec(){ sops_check || return 1; local enc plain; enc="$(sec_enc)"; plain="$(sec_plain)"; if [ ! -f "$enc" ]; then err "missing encrypted file: $(basename "$enc")"; return 1; fi; sops --decrypt "$enc" > "$plain" || return 1; ${EDITOR:-${VISUAL:-nano}} "$plain"; sops --encrypt "$plain" > "$enc" || return 1; shred -u "$plain" 2>/dev/null || rm -f "$plain"; ok "updated $(basename "$enc")"; }

cmd_db_init(){
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup not run (./setup.sh)"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv"; return 1; fi
  (cd "$ROOT_DIR" && PYTHONPATH="$ROOT_DIR:$(pwd)/packages/core/src" "$ROOT_DIR/venv/bin/python" -m vibrae_core.init_db)
  ok "database initialized"
}

cmd_env_sync(){
  ensure_env
  local defaults
  defaults=$(cat <<'DEFEOF'
AUTOSTART=false
MUSIC_MODE=folder
MUSIC_DIR=music
USB_SUBDIR=
VIBRAE_MUSIC=
FRONTEND_DIST=/apps/web/dist
# WEB_DIST deprecated; FRONTEND_DIST is canonical
FRONTEND_PORT=9081
BACKEND_PORT=8000
BACKEND_MODULE=apps.api.src.vibrae_api.main:app
SECRET_KEY=change-me-please
LOG_LEVEL=INFO
LOG_KEEP=5
LOG_ROTATE_INTERVAL_HOURS=12
DOMAIN=
NGINX_CONF=nginx.conf
TUNNEL=cloudflared
CLOUDFLARE_TUNNEL_TOKEN=
DEFEOF
)
  local added=0
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    local key="${line%%=*}"; local val="${line#*=}"
    if ! grep -qE "^${key}=" "$ENV_FILE" 2>/dev/null; then
      echo "${key}=${val}" >> "$ENV_FILE"; added=$((added+1))
    fi
  done <<< "$defaults"
  [ $added -gt 0 ] && ok "Added $added missing keys" || ok ".env already has recommended keys"
}

cmd_autostart(){ case "$1" in on) kv_set AUTOSTART true; ok "AUTOSTART=true";; off) kv_set AUTOSTART false; ok "AUTOSTART=false";; *) err "usage: vibrae autostart on|off"; return 1;; esac }

cmd_source_detect(){
  ensure_env
  local mode dir label
  mode="$(kv_get MUSIC_SOURCE_MODE)"; [ -n "$mode" ] || mode="$(kv_get MUSIC_MODE)"; [ -n "$mode" ] || mode="folder"
  dir="$(kv_get MUSIC_DIR)"; [ -n "$dir" ] || dir="music"
  label="$(kv_get VIBRAE_MUSIC)"; [ -n "$label" ] || label="$(kv_get USB_VOLUME_LABEL)"
  if [ -z "$label" ] && [ "$mode" = "usb" ]; then
    warn "VIBRAE_MUSIC not set (USB volume label). USB_VOLUME_LABEL is deprecated; set VIBRAE_MUSIC instead."
  fi
  if [ "$mode" = "usb" ]; then [ -n "$label" ] && echo "usb:$label" || echo "usb:(no label)"; else echo "folder:$dir"; fi
}

cmd_check_env(){
  banner
  ensure_env
  local issues=0
  check(){ local k="$1"; local msg="$2"; local v; v="$(kv_get "$k")"; if [ -z "$v" ]; then issues=$((issues+1)); printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "$k" "$msg"; fi }
  check SECRET_KEY "JWT signing secret is required"
  check BACKEND_PORT "defaults to 8000 if unset"
  check FRONTEND_PORT "defaults to 9081 if unset"
  check FRONTEND_DIST "path to exported web (default /apps/web/dist)"
  # Music/source
  local mode; mode="$(kv_get MUSIC_MODE)"; [ -z "$mode" ] && mode="$(kv_get MUSIC_SOURCE_MODE)"
  if [ -z "$mode" ]; then printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "MUSIC_MODE" "folder|usb (default folder)"; issues=$((issues+1)); fi
  if [ "$mode" = "usb" ]; then
    local label; label="$(kv_get USB_VOLUME_LABEL)"; [ -z "$label" ] && label="$(kv_get VIBRAE_MUSIC)"
    [ -z "$label" ] && printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "VIBRAE_MUSIC" "USB volume label or absolute mount path"
  fi
  # Tunneling
  local tunnel; tunnel="$(kv_get TUNNEL)"; [ -z "$tunnel" ] && tunnel="cloudflared"
  if [ "$tunnel" = "cloudflared" ]; then
    local tok; tok="$(kv_get CLOUDFLARE_TUNNEL_TOKEN)"; [ -z "$tok" ] && printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "CLOUDFLARE_TUNNEL_TOKEN" "required when TUNNEL=cloudflared"
  fi
  [ $issues -eq 0 ] && ok "env looks good" || warn "$issues item(s) to review"
}

cmd_doctor(){
  banner
  hdr "Tools"
  command -v python3 >/dev/null && ok "python3" || err "python3 MISSING"
  command -v pip >/dev/null && ok "pip" || err "pip MISSING"
  command -v node >/dev/null && ok "node" || warn "node not found (frontend optional)"
  command -v npm >/dev/null && ok "npm" || warn "npm not found (frontend optional)"
  command -v nginx >/dev/null && ok "nginx" || warn "nginx not found (reverse proxy optional)"
  command -v cloudflared >/dev/null && ok "cloudflared" || warn "cloudflared not found (public URL optional)"
  if [[ "$(uname)" == "Darwin" ]]; then
    command -v brew >/dev/null && ok "brew" || warn "brew not found (auto-install skipped)"
  fi
  hdr "Python"
  if [ -d "$ROOT_DIR/venv" ]; then
  "$ROOT_DIR/venv/bin/python" - <<'PY'
import sys
mods=["fastapi","uvicorn","sqlalchemy","pydantic","jose","python_dotenv","websockets","vlc"]
missing=[]
for m in mods:
  try:
    __import__(m)
  except Exception:
    missing.append(m)
if missing:
  print("[warn] missing modules:", ", ".join(missing))
else:
  print("[ok] Python deps present")
try:
  import vlc
  try:
    _=vlc.Instance()
    print("[ok] libVLC available")
  except Exception:
    print("[warn] libVLC not available; install VLC media player")
except Exception:
  pass
PY
  else
  warn "venv not found; run ./setup.sh"
  fi
}

# --- Raspberry Pi helpers ---
is_pi(){ [ -f /etc/raspberrypi-release ] || grep -qi 'raspberry' /proc/cpuinfo 2>/dev/null || grep -qi 'raspi' /proc/cpuinfo 2>/dev/null; }
cmd_pi_install(){ license_notice; if ! is_pi; then warn "Not a Raspberry Pi (continuing anyway)"; fi; sudo bash "$ROOT_DIR/scripts/pi/setup.sh"; }
cmd_pi_start(){
  license_notice
  if [ ! -f "$ROOT_DIR/.installed" ]; then warn "setup has not been run locally; proceeding with Pi systemd start"; fi
  sudo bash "$ROOT_DIR/scripts/pi/run.sh"
}
cmd_pi_stop(){ license_notice; sudo bash "$ROOT_DIR/scripts/pi/stop.sh"; }
cmd_pi_status(){ banner; systemctl --no-pager status vibrae-backend vibrae-frontend vibrae-cloudflared || true; }
cmd_pi_logs(){ local unit="${1:-vibrae-backend}"; journalctl -u "$unit" -f; }

# Enable extended glob for trimming
shopt -s extglob 2>/dev/null || true

run_interactive(){
  banner
  # attempt autostart if enabled
  autostart_maybe_start || true
  printf "Type 'help' for commands, 'quit' to exit.\n"
  while true; do
    if read -e -r -p "vibrae> " line; then
      # trim
      line="${line##+([[:space:]])}"
      line="${line%%+([[:space:]])}"
      case "$line" in
        "" ) continue ;;
        quit|exit ) break ;;
        help ) usage; echo; continue ;;
  clear ) clear 2>/dev/null || printf '\033c'; echo; continue ;;
      esac
      IFS=' ' read -r -a args <<< "$line"
  set +e
      dispatch "${args[@]}"
      rc=$?
      set -e
      echo
    else
      break
    fi
  done
}

dispatch(){
  # With 'set -u', $1 may be unset when no args are passed; default to empty
  case "${1-}" in
  --version|version) shift; echo "vibrae ${VERSION}"; return 0;;
    install) shift; cmd_install "$@";;
    start|up) shift; cmd_start "$@";;
    stop|down) shift; cmd_stop "$@";;
    restart) shift; cmd_restart "$@";;
    status) shift; cmd_status "$@";;
    logs) shift; cmd_logs "$@";;
  front) shift; case "$1" in restart) shift; cmd_front_restart ;; *) usage; return 1;; esac ;;
    open) shift; cmd_open "$@";;
    url) shift; cmd_url "$@";;

    contact) shift; contact_information "$@";;
    github) shift; cmd_github "$@";;

  env) shift; case "${1-}" in show) shift; cmd_env_show;; edit) shift; cmd_env_edit;; encrypt) shift; cmd_env_encrypt;; decrypt) shift; cmd_env_decrypt;; edit-sec) shift; cmd_env_edit_sec;; set) shift; cmd_env_set "$@";; sync) shift; cmd_env_sync;; *) usage; return 1;; esac;;

  db) shift; case "${1-}" in init) shift; cmd_db_init ;; *) usage; return 1;; esac;;

    autostart) shift; cmd_autostart "$@";;
    source) shift; case "$1" in detect) shift; cmd_source_detect;; *) usage; return 1;; esac;;

    check-env) shift; cmd_check_env;;
  check) shift; cmd_check_env;;
    doctor) shift; cmd_doctor;;
  clear) clear 2>/dev/null || printf '\033c';;
  pi) shift; case "${1-}" in install) shift; cmd_pi_install;; start) shift; cmd_pi_start;; stop) shift; cmd_pi_stop;; status) shift; cmd_pi_status;; logs) shift; cmd_pi_logs "$@";; *) usage; return 1;; esac;;
    help|--help|-h) usage;;
    shell|"") run_interactive;;
    *) err "Unknown command: $1"; usage; return 1;;
  esac
}

main(){ dispatch "$@"; }

main "$@"
