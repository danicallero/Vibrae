#!/bin/bash
# formatting helpers (defined early for later use)
hdr(){ printf "%b%s%b\n" "$BOLD" "$*" "$RESET"; }
line(){ printf '%s\n' '--------------------------------------------------'; }
section(){ echo; hdr "$1"; line; }
# SPDX-License-Identifier: GPL-3.0-or-later
# Vibrae CLI: install, run, inspect.
# Usage: vibrae <command> [args]

set -o pipefail
IFS=$'\n\t'

# Minimal err before color setup
err(){ printf 'x %s\n' "$*" 1>&2; }

VERSION="0.4.1"

trap_handler(){
  local rc=$?; local ln=${LINENO}
  # Skip trap until fully init
  if [ -z "${_VIBRAE_TRAP_READY:-}" ] || [ -n "${_VIBRAE_SUPPRESS_TRAP:-}" ]; then return; fi
  err "unexpected error (line ${ln})"; return $rc
}
# Trap disabled (too noisy)
unset _VIBRAE_SUPPRESS_TRAP 2>/dev/null || true

# Enable -u later
DEFER_SET_U=1

# Resolve script path (handles symlinks)
resolve_self(){
  local src="${BASH_SOURCE[0]}"
  while [ -h "$src" ]; do
    local dir; dir="$(cd -P "$(dirname "$src")" && pwd)"
    src="$(readlink "$src")"
    [[ "$src" != /* ]] && src="$dir/$src"
  done
  printf '%s' "$src"
}
SCRIPT_PATH="$(resolve_self)"
ROOT_DIR="$(cd -P "$(dirname "$SCRIPT_PATH")" && pwd)"
ENV_FILE="$ROOT_DIR/config/env/.env.backend"
ENV_EXAMPLE="$ROOT_DIR/config/env/.env.backend.example"
LOG_DIR="$ROOT_DIR/logs"

# colors (respect NO_COLOR/no TTY)
if [ -z "${NO_COLOR:-}" ] && [ -t 1 ] && command -v tput >/dev/null 2>&1 && [ "$(tput colors 2>/dev/null || echo 0)" -ge 8 ]; then
  BOLD="$(tput bold)"; RESET="$(tput sgr0)";
  RED="$(tput setaf 1)"; GREEN="$(tput setaf 2)"; YELLOW="$(tput setaf 3)"; BLUE="$(tput setaf 4)"; GREY="$(tput setaf 8)";
else BOLD=""; RESET=""; RED=""; GREEN=""; YELLOW=""; BLUE=""; GREY=""; fi
ok(){ printf "%b✔%b %s\n" "$GREEN" "$RESET" "$*"; }
warn(){ printf "%b!%b %s\n" "$YELLOW" "$RESET" "$*"; }
err(){ printf "%bx%b %s\n" "$RED" "$RESET" "$*" 1>&2; }
hdr(){ printf "%b%s%b\n" "$BOLD" "$*" "$RESET"; }

banner(){ printf "=== %bVibrae%b ===\n" "$BOLD" "$RESET"; }

license_notice(){ printf "%bVibrae%b (GPLv3, no warranty)\n" "$BOLD" "$RESET"; }

contact_information(){
  printf "%bContact%b\n" "$BOLD" "$RESET"
  printf "Issues: GitHub repo (vibrae). Email: vibrae@danicallero.es\n"
}

usage(){
  banner; section "Core"; cat <<EOF
  ${BOLD}version${RESET}             Show CLI version
  ${BOLD}install${RESET}             Install/update dependencies (scripts/app/setup.sh)
  ${BOLD}start${RESET} | up          Start all services (run.sh)
  ${BOLD}stop${RESET} | down         Stop all services (stop.sh)
  ${BOLD}restart${RESET}             Stop then start
  ${BOLD}status${RESET}              Show service status (process + health)
  ${BOLD}logs${RESET} [name] [n]     Tail logs (backend|player|serve|cloudflared). Default all; n=100
  ${BOLD}front restart${RESET}       Restart only static server
  ${BOLD}open${RESET}                Open web UI
  ${BOLD}url${RESET}                 Print local/public URLs
EOF
  section "Environment & Secrets"; cat <<EOF
  ${BOLD}env show${RESET}            Print .env (aliases: env ls, env cat)
  ${BOLD}env edit${RESET}            Edit .env
  ${BOLD}env set${RESET} KEY=VALUE   Set or add a key
  ${BOLD}env sync${RESET}            Add any missing recommended keys
  ${BOLD}env encrypt${RESET}         Encrypt backend env (.env.backend)
  ${BOLD}env decrypt${RESET}         Decrypt backend env
  ${BOLD}env edit-sec${RESET}        Decrypt, edit, re-encrypt backend env
  ${BOLD}env f-encrypt${RESET}       Encrypt frontend env (EXPO_PUBLIC_*)
  ${BOLD}env f-decrypt${RESET}       Decrypt frontend env
  ${BOLD}env f-edit-sec${RESET}      Decrypt, edit, re-encrypt frontend env
  ${BOLD}env help${RESET}            Env-only help & tips
EOF
  section "Database"; echo "  ${BOLD}db init${RESET}             Create tables & seed admin (if absent)" 
  section "Music Source"; cat <<EOF
  ${BOLD}source detect${RESET}       Show resolved source (folder:/path or usb:LABEL)
  ${BOLD}autostart${RESET} on|off    Toggle AUTOSTART (auto start on shell entry)
EOF
  section "Diagnostics"; cat <<EOF
  ${BOLD}check-env${RESET}           Validate .env values
  ${BOLD}doctor${RESET}              Check required tools & deps
EOF
  section "Aliases"; cat <<EOF
  ahelp                  Show alias list
  ver -> version         st -> status
  ce  -> check-env       doc -> doctor
  sh  -> shell           ls-env|env ls|env cat -> env show
  env get KEY            Print single env value
EOF
  section "Raspberry Pi"; cat <<EOF
  ${BOLD}pi install${RESET}          Pi setup (systemd, nginx)
  ${BOLD}pi start|stop|status${RESET} Manage Pi services
  ${BOLD}pi logs${RESET} [unit]      Tail journal for a unit
EOF
  section "Misc"; cat <<EOF
  ${BOLD}shell${RESET}               Interactive shell
  ${BOLD}clear${RESET}               Clear the screen
  ${BOLD}ahelp${RESET}               Show command aliases
  ${BOLD}help${RESET}                Show this help
EOF
  line;echo
}

onboarding_message(){
  echo
  warn "Vibrae is not installed yet (missing .installed or venv)"
  echo "Next steps:"
  echo "  1. Run: vibrae install   # installs deps"
  echo "  2. Edit env: vibrae env edit (or sync)"
  echo "  3. Init DB: vibrae db init"
  echo "  4. Start: vibrae start"
  echo ""; echo "Shortcuts:"
  echo "  vibrae install && vibrae db init && vibrae start" 
  echo
}

ensure_env(){
  # No auto migration of root .env.
  if [ -f "$ROOT_DIR/.env" ]; then
    warn "root .env is ignored; run 'vibrae env migrate' for legacy rename if desired"
  fi
  # Encrypted env present, skip creating placeholder.
  if [ ! -f "$ENV_FILE" ] && [ -f "${ENV_FILE}.enc" ]; then
    warn "found encrypted backend env ($(basename "${ENV_FILE}.enc")) but no plaintext; decrypt with: vibrae env decrypt"
    return 0
  fi
  if [ ! -f "$ENV_FILE" ]; then
    mkdir -p "$(dirname "$ENV_FILE")" 2>/dev/null || true
    if [ -f "$ENV_EXAMPLE" ]; then
      cp "$ENV_EXAMPLE" "$ENV_FILE"
      ok "created $(basename "$ENV_FILE") from example"
    else
      cat > "$ENV_FILE" <<'EOENV'
# Vibrae environment
BACKEND_PORT=8000
BACKEND_MODULE=apps.api.src.vibrae_api.main:app
FRONTEND_PORT=9081
FRONTEND_DIST=/apps/web/dist
MUSIC_MODE=folder
MUSIC_DIR=music
SECRET_KEY=change-me-please
LOG_LEVEL=INFO
EOENV
      ok "initialized $(basename "$ENV_FILE") with defaults"
    fi
  fi
  if ! grep -qE '^[A-Z0-9_]+=.*' "$ENV_FILE"; then
    warn "env file has no KEY= entries; add variables or run 'vibrae env sync'"
  fi
}

run_script(){
  local script="$1"
  local candidate
  # Preferred exact path at root
  if [ -f "$ROOT_DIR/$script" ]; then
    candidate="$ROOT_DIR/$script"
  elif [ -f "$ROOT_DIR/scripts/app/$script" ]; then
    candidate="$ROOT_DIR/scripts/app/$script"
  else
    err "script not found: $script (looked in . and scripts/app)"; return 1
  fi
  if [ ! -x "$candidate" ]; then chmod +x "$candidate" 2>/dev/null || true; fi
  (cd "$ROOT_DIR" && bash "$candidate")
}

kv_set(){
  local key="$1"; local val="$2"
  ensure_env
  local tmp
  tmp="$(mktemp 2>/dev/null || true)"
  if [ -z "$tmp" ]; then tmp="${ENV_FILE}.tmp.$$"; fi
  awk -v K="$key" -v V="$val" '
    BEGIN{ set=0 }
    /^[#[:space:]]/ { print; next }
    $0 ~ "^"K"=" { if(!set){ print K"="V; set=1 } ; next }
    { print }
    END{ if(!set) print K"="V }
  ' "$ENV_FILE" > "$tmp" && mv "$tmp" "$ENV_FILE"
}
kv_get(){ local key="$1"; [ -f "$ENV_FILE" ] || return 1; grep -E "^${key}=" "$ENV_FILE" | head -n1 | sed -E "s/^${key}=//"; }

# helpers
truthy(){ case "$(echo "$1" | tr '[:upper:]' '[:lower:]')" in true|1|yes|on) return 0;; *) return 1;; esac }
is_uvicorn_running(){
  # Avoid triggering ERR trap when uvicorn is not running (pgrep exit 1 is expected)
  pgrep -f "uvicorn" >/dev/null 2>&1 || return 1
}

autostart_maybe_start(){
  ensure_env
  local as; as="$(kv_get AUTOSTART)"
  if truthy "$as"; then
    if is_uvicorn_running; then
      ok "AUTOSTART on; already running"
    else
      if [ ! -f "$ROOT_DIR/.installed" ] || [ ! -d "$ROOT_DIR/venv" ]; then
  warn "AUTOSTART on but setup not completed; run scripts/app/setup.sh first"
      else
        warn "AUTOSTART on; starting services"
        cmd_start
      fi
    fi
    return 0
  fi
  return 1
}

cmd_install(){ run_script scripts/app/setup.sh; }
cmd_start(){
  # Require install stamp and venv
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup has not been run. Run: scripts/app/setup.sh or 'vibrae install'"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv. Run: scripts/app/setup.sh"; return 1; fi
  run_script run.sh;
}
cmd_stop(){ run_script stop.sh; }
cmd_restart(){
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup has not been run. Run: scripts/app/setup.sh or 'vibrae install'"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv. Run: scripts/app/setup.sh"; return 1; fi
  license_notice; cmd_stop || true; cmd_start;
}

service_row(){
  local name="$1"; local patt="$2"; local psout="$3"
  if echo "$psout" | grep -E "$patt" | grep -v grep >/dev/null; then
    printf "  %b●%b %-12s %brunning%b\n" "$GREEN" "$RESET" "$name" "$GREEN" "$RESET"
  else
    printf "  %b○%b %-12s %bstopped%b\n" "$GREY" "$RESET" "$name" "$GREY" "$RESET"
  fi
}
cmd_status(){
  banner
  local psout; psout="$(/bin/ps aux || ps -ef || true)"
  section "Services"; service_row "uvicorn" "uvicorn" "$psout"; service_row "static-serve" "(serve -s|npx serve)" "$psout"; service_row "cloudflared" "cloudflared" "$psout"
  # Frontend mode detection
  local mode="backend"
  if echo "$psout" | grep -E "(serve -s|npx serve)" >/dev/null; then mode="npx"; fi
  printf "\nFrontend: %s\n" "$mode"
  # health via backend
  local api_url="http://127.0.0.1/api/health"
  local json; json="$(curl -s "$api_url" || echo '')"
  if [ -n "$json" ]; then
    local backend fe fe_mode player proxy cf fe_srv
    backend=$(echo "$json" | sed -n 's/.*"backend"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    fe=$(echo "$json" | sed -n 's/.*"frontend"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    fe_mode=$(echo "$json" | sed -n 's/.*"frontend_mode"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    player=$(echo "$json" | sed -n 's/.*"player"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    proxy=$(echo "$json" | sed -n 's/.*"proxy"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    cf=$(echo "$json" | sed -n 's/.*"cloudflared"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    fe_srv=$(echo "$json" | sed -n 's/.*"frontend_server"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -n1)
    printf "\nHealth\n"
    printf "  backend:   %s\n" "${backend:-unknown}"
    printf "  player:    %s\n" "${player:-unknown}"
    printf "  frontend:  %s (mode=%s, static=%s)\n" "${fe:-unknown}" "${fe_mode:-auto}" "${fe_srv:-down}"
    printf "  proxy:     %s\n" "${proxy:-unknown}"
    printf "  tunnel:    %s\n" "${cf:-unknown}"
  else
    printf "API (/api/health): unreachable\n"
  fi
}

cmd_logs(){
  mkdir -p "$LOG_DIR" 2>/dev/null || true
  local name="$1"; shift || true
  local lines="${1:-100}"
  if [ -z "$name" ]; then
    for f in backend player serve cloudflared; do
      hdr "$f.log"; tail -n "$lines" "$LOG_DIR/$f.log" 2>/dev/null || warn "no $f.log"; echo
    done
  else
    hdr "$name.log"; tail -n "$lines" "$LOG_DIR/$name.log" 2>/dev/null || err "no such log: $name"
  fi
}

cmd_front_restart(){
  # Restart only the npx static server
  banner
  hdr "Frontend restart"
  pkill -f "(serve -s|npx serve)" >/dev/null 2>&1 || true
  sleep 0.5
  # Re-run the portion from run.sh that starts npx if possible
  FRONTEND_DIST_VAL="$(kv_get FRONTEND_DIST)"; [ -n "$FRONTEND_DIST_VAL" ] || FRONTEND_DIST_VAL="/apps/web/dist"
  SERVE_ROOT="$ROOT_DIR$FRONTEND_DIST_VAL"
  PORT_VAL="$(kv_get FRONTEND_PORT)"; [ -n "$PORT_VAL" ] || PORT_VAL=9081
  if command -v npx >/dev/null 2>&1 && [ -d "$SERVE_ROOT" ]; then
    mkdir -p "$LOG_DIR" 2>/dev/null || true
    echo "----- $(date) front restart on :$PORT_VAL -----" >> "$LOG_DIR/serve.log"
    (cd "$ROOT_DIR" && FRONTEND_MODE=npx nohup npx serve -s "$SERVE_ROOT" -l "$PORT_VAL" >> "$LOG_DIR/serve.log" 2>&1 &)
    ok "frontend restarted on :$PORT_VAL (mode=npx)"
  else
    warn "npx or export missing; backend will serve static files if available"
  fi
}

cmd_github(){
  local url="https://github.com/danicallero/Vibrae"
  if [[ "$(uname)" == "Darwin" ]]; then open "$url"; echo "Repo: $url"; else xdg-open "$url" 2>/dev/null; echo "Repo: $url" || echo "$url"; fi
}

cmd_open(){
  local domain; domain="$(kv_get DOMAIN)"
  local port; port="$(kv_get FRONTEND_PORT)"; [ -n "$port" ] || port=9081
  local url
  if [ -n "$domain" ]; then url="https://$domain"; else url="http://127.0.0.1:80"; fi
  if [[ "$(uname)" == "Darwin" ]]; then open "$url"; else xdg-open "$url" 2>/dev/null || echo "$url"; fi
}
cmd_url(){
  local port; port="$(kv_get FRONTEND_PORT)"; [ -n "$port" ] || port=9081
  echo "Local (nginx):  http://127.0.0.1"
  echo "Local (static): http://127.0.0.1:$port"
  local domain; domain="$(kv_get DOMAIN)"; [ -n "$domain" ] && echo "Public: https://$domain"
}

cmd_env_show(){ ensure_env; cat "$ENV_FILE"; }
cmd_env_edit(){ ensure_env; if [[ "$(uname)" == "Darwin" ]] && [ -z "${EDITOR}${VISUAL}" ]; then open -e "$ENV_FILE"; else ${EDITOR:-${VISUAL:-nano}} "$ENV_FILE"; fi }
cmd_env_set(){
  local kv="$1"; if ! echo "$kv" | grep -q '='; then err "usage: vibrae env set KEY=VALUE"; return 1; fi
  local key="${kv%%=*}"; local val="${kv#*=}"; kv_set "$key" "$val"; ok "$key set"
}

env_help(){
  cat <<EOE
Environment
  env show|ls|cat   Print backend env (.env.backend)
  env edit          Edit backend env
  env set K=V       Set/add a key
  env get KEY       Print one value
  env sync          Add missing recommended keys
  env encrypt       Encrypt backend env (.env.backend -> .env.backend.enc)
  env decrypt       Decrypt backend env
  env edit-sec      Decrypt, edit, re-encrypt backend env
  env f-encrypt     Encrypt frontend env
  env f-decrypt     Decrypt frontend env
  env f-edit-sec    Decrypt, edit, re-encrypt frontend env

Notes
  - Files: config/env/.env.backend(.enc), .env.frontend(.enc)
  - If only .enc exists, decrypt before check-env
  - Never commit plaintext secrets
EOE
}

env_get(){ ensure_env; local k="$1"; [ -z "$k" ] && { err "usage: vibrae env get KEY"; return 1; }; kv_get "$k" || true; }

# --- SOPS environment encryption helpers ---
sops_check(){ if ! command -v sops >/dev/null 2>&1; then err "sops not installed (https://github.com/getsops/sops)"; return 1; fi }
sec_dir(){ printf '%s' "$ROOT_DIR/config/env"; }
sec_plain(){ printf '%s' "$(sec_dir)/.env.backend"; }
sec_enc(){ printf '%s' "$(sec_dir)/.env.backend.enc"; }
sec_front_plain(){ printf '%s' "$(sec_dir)/.env.frontend"; }
sec_front_enc(){ printf '%s' "$(sec_dir)/.env.frontend.enc"; }

# Unified SOPS runner with parse-error guidance
_sops_run(){ # _sops_run <encrypt|decrypt> <input> <output>
  local mode="$1"; shift; local in="$1"; shift; local out="$1"; shift || true
  local cmd=(sops)
  # Prefer repo config to avoid broken global ~/.sops.yaml issues
  if [ -f "$ROOT_DIR/.sops.yaml" ]; then
    if [ -z "${SOPS_CONFIG:-}" ]; then cmd+=(--config "$ROOT_DIR/.sops.yaml"); fi
  fi
  # Temporarily suppress generic trap noise
  local prev_suppress="${_VIBRAE_SUPPRESS_TRAP:-}"
  _VIBRAE_SUPPRESS_TRAP=1
  case "$mode" in
    encrypt) "${cmd[@]}" --encrypt "$in" > "$out" 2>"$out.err" ;;
    decrypt) "${cmd[@]}" --decrypt "$in" > "$out" 2>"$out.err" ;;
    *) err "_sops_run: invalid mode '$mode'"; return 1;;
  esac
  local rc=$?
  if [ $rc -ne 0 ]; then
    if grep -qi 'unmarshal' "$out.err" 2>/dev/null; then
      err "sops parse error (YAML). Likely a broken global ~/.sops.yaml. Try: mv ~/.sops.yaml ~/.sops.yaml.bak && retry, or export SOPS_CONFIG=./.sops.yaml"
    else
      err "sops $mode failed: $(sed -e 's/\r//g' "$out.err" | tail -n3 | tr '\n' ' ' | sed -E 's/[[:space:]]+/ /g')"
    fi
    rm -f "$out.err" 2>/dev/null || true
    # Keep suppression active for this failing path
    return 1
  fi
  # Success path: restore suppression state
  if [ -n "$prev_suppress" ]; then _VIBRAE_SUPPRESS_TRAP="$prev_suppress"; else unset _VIBRAE_SUPPRESS_TRAP; fi
  rm -f "$out.err" 2>/dev/null || true
  return 0
}

cmd_env_encrypt(){
  sops_check || return 1
  local plain enc; plain="$(sec_plain)"; enc="$(sec_enc)"
  if [ ! -f "$plain" ]; then err "plaintext backend env $(basename "$plain") not found"; return 1; fi
  if ! grep -qE '^[A-Z0-9_]+=.*' "$plain"; then err "refusing to encrypt empty env (no KEY= lines)"; return 1; fi
  _sops_run encrypt "$plain" "$enc" || return 1
  # Plaintext intentionally retained (workflow requires working copy). DO NOT COMMIT.
  ok "encrypted -> $(basename "$enc") (plaintext kept; DO NOT COMMIT)"
}
cmd_env_decrypt(){ sops_check || return 1; local plain enc; plain="$(sec_plain)"; enc="$(sec_enc)"; if [ ! -f "$enc" ]; then err "encrypted backend file missing: $(basename "$enc")"; return 1; fi; _sops_run decrypt "$enc" "$plain" || return 1; ok "decrypted to $(basename "$plain") (DO NOT COMMIT)"; }
cmd_env_edit_sec(){
  # Decrypt -> edit -> re-encrypt, but retain updated plaintext (.env.backend)
  sops_check || return 1
  local enc plain; enc="$(sec_enc)"; plain="$(sec_plain)"
  if [ ! -f "$enc" ]; then err "missing encrypted backend file: $(basename "$enc")"; return 1; fi
  _sops_run decrypt "$enc" "$plain" || return 1
  ${EDITOR:-${VISUAL:-nano}} "$plain"
  _sops_run encrypt "$plain" "$enc" || return 1
  # DO NOT delete plaintext (intentional change from previous behavior)
  ok "updated $(basename "$enc") (plaintext retained; DO NOT COMMIT)"
}
cmd_env_f_encrypt(){
  sops_check || return 1
  local plain enc; plain="$(sec_front_plain)"; enc="$(sec_front_enc)"
  if [ ! -f "$plain" ]; then err "plaintext $(basename "$plain") not found"; return 1; fi
  _sops_run encrypt "$plain" "$enc" || return 1
  # Keep plaintext for active development; remind user not to commit.
  ok "encrypted -> $(basename "$enc") (plaintext kept; DO NOT COMMIT)"
}
cmd_env_f_decrypt(){ sops_check || return 1; local plain enc; plain="$(sec_front_plain)"; enc="$(sec_front_enc)"; if [ ! -f "$enc" ]; then err "encrypted file missing: $(basename "$enc")"; return 1; fi; _sops_run decrypt "$enc" "$plain" || return 1; ok "decrypted to $(basename "$plain") (DO NOT COMMIT)"; }
cmd_env_f_edit_sec(){
  # Frontend decrypt -> edit -> re-encrypt; retain plaintext (.env.frontend).
  # Warn users not to commit the plaintext file.
  sops_check || return 1
  local enc plain; enc="$(sec_front_enc)"; plain="$(sec_front_plain)"
  if [ ! -f "$enc" ]; then err "missing encrypted file: $(basename "$enc")"; return 1; fi
  _sops_run decrypt "$enc" "$plain" || return 1
  ${EDITOR:-${VISUAL:-nano}} "$plain"
  _sops_run encrypt "$plain" "$enc" || return 1
  ok "updated $(basename "$enc") (plaintext retained; DO NOT COMMIT)"
}

cmd_db_init(){
  if [ ! -f "$ROOT_DIR/.installed" ]; then err "setup not run (scripts/app/setup.sh)"; return 1; fi
  if [ ! -d "$ROOT_DIR/venv" ]; then err "missing venv"; return 1; fi
  (cd "$ROOT_DIR" && PYTHONPATH="$ROOT_DIR:$(pwd)/packages/core/src" "$ROOT_DIR/venv/bin/python" -m vibrae_core.init_db)
  ok "database initialized"
}

cmd_env_sync(){
  ensure_env
  local defaults
  defaults=$(cat <<'DEFEOF'
AUTOSTART=false
MUSIC_MODE=folder
MUSIC_DIR=music
USB_SUBDIR=
VIBRAE_MUSIC=
FRONTEND_DIST=/apps/web/dist
# WEB_DIST deprecated; FRONTEND_DIST is canonical
FRONTEND_PORT=9081
BACKEND_PORT=8000
BACKEND_MODULE=apps.api.src.vibrae_api.main:app
SECRET_KEY=change-me-please
LOG_LEVEL=INFO
LOG_KEEP=5
LOG_ROTATE_INTERVAL_HOURS=12
DOMAIN=
NGINX_CONF=nginx.conf
TUNNEL=cloudflared
CLOUDFLARE_TUNNEL_TOKEN=
DEFEOF
)
  local added=0
  while IFS= read -r line; do
    [ -z "$line" ] && continue
    local key="${line%%=*}"; local val="${line#*=}"
    if ! grep -qE "^${key}=" "$ENV_FILE" 2>/dev/null; then
      echo "${key}=${val}" >> "$ENV_FILE"; added=$((added+1))
    fi
  done <<< "$defaults"
  [ $added -gt 0 ] && ok "Added $added missing keys" || ok ".env already has recommended keys"
}

cmd_autostart(){ case "$1" in on) kv_set AUTOSTART true; ok "AUTOSTART=true";; off) kv_set AUTOSTART false; ok "AUTOSTART=false";; *) err "usage: vibrae autostart on|off"; return 1;; esac }

cmd_source_detect(){
  ensure_env
  local mode dir label
  mode="$(kv_get MUSIC_SOURCE_MODE)"; [ -n "$mode" ] || mode="$(kv_get MUSIC_MODE)"; [ -n "$mode" ] || mode="folder"
  dir="$(kv_get MUSIC_DIR)"; [ -n "$dir" ] || dir="music"
  label="$(kv_get VIBRAE_MUSIC)"; [ -n "$label" ] || label="$(kv_get USB_VOLUME_LABEL)"
  if [ -z "$label" ] && [ "$mode" = "usb" ]; then
    warn "VIBRAE_MUSIC not set (USB volume label). USB_VOLUME_LABEL is deprecated; set VIBRAE_MUSIC instead."
  fi
  if [ "$mode" = "usb" ]; then [ -n "$label" ] && echo "usb:$label" || echo "usb:(no label)"; else echo "folder:$dir"; fi
}

cmd_check_env(){
  banner
  ensure_env
  # Encrypted env awareness / freshness check
  local ENC_FILE="${ENV_FILE}.enc"
  if [ -f "$ENC_FILE" ]; then
    if [ ! -f "$ENV_FILE" ]; then
      # ensure_env would have already warned and skipped creation; exit early
      warn "cannot validate keys until you decrypt the backend env"
      echo "Run: vibrae env decrypt"
      return 2
    fi
    if [ "$ENC_FILE" -nt "$ENV_FILE" ]; then
      warn "encrypted backend env is newer than plaintext; run: vibrae env decrypt"
    else
      ok "encrypted backend env detected (plaintext appears current)"
    fi
  fi
  local issues=0
  _VIBRAE_SUPPRESS_TRAP=1
  check(){
    local k="$1"; local msg="$2"; local v
    v="$(kv_get "$k" || true)"
    if [ -z "${v}" ]; then
      issues=$((issues+1))
      printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "$k" "$msg"
    fi
  }
  check SECRET_KEY "JWT signing secret is required"
  check BACKEND_PORT "defaults to 8000 if unset"
  check FRONTEND_PORT "defaults to 9081 if unset"
  check FRONTEND_DIST "path to exported web (default /apps/web/dist)"
  # Music/source
  local mode; mode="$(kv_get MUSIC_MODE || true)"; [ -z "$mode" ] && mode="$(kv_get MUSIC_SOURCE_MODE || true)"
  if [ -z "$mode" ]; then printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "MUSIC_MODE" "folder|usb (default folder)"; issues=$((issues+1)); fi
  if [ "$mode" = "usb" ]; then
    local label; label="$(kv_get USB_VOLUME_LABEL || true)"; [ -z "$label" ] && label="$(kv_get VIBRAE_MUSIC || true)"
    [ -z "$label" ] && printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "VIBRAE_MUSIC" "USB volume label or absolute mount path"
  fi
  # Tunneling
  local tunnel; tunnel="$(kv_get TUNNEL || true)"; [ -z "$tunnel" ] && tunnel="cloudflared"
  if [ "$tunnel" = "cloudflared" ]; then
    local tok; tok="$(kv_get CLOUDFLARE_TUNNEL_TOKEN || true)"; [ -z "$tok" ] && printf "  %b•%b %-26s %s\n" "$YELLOW" "$RESET" "CLOUDFLARE_TUNNEL_TOKEN" "required when TUNNEL=cloudflared"
  fi
  unset _VIBRAE_SUPPRESS_TRAP
  [ $issues -eq 0 ] && ok "env looks good" || warn "$issues item(s) to review"
}

cmd_doctor(){
  banner
  hdr "Tools"
  command -v python3 >/dev/null && ok "python3" || err "python3 MISSING"
  command -v pip >/dev/null && ok "pip" || err "pip MISSING"
  command -v node >/dev/null && ok "node" || warn "node not found (frontend optional)"
  command -v npm >/dev/null && ok "npm" || warn "npm not found (frontend optional)"
  command -v nginx >/dev/null && ok "nginx" || warn "nginx not found (reverse proxy optional)"
  command -v cloudflared >/dev/null && ok "cloudflared" || warn "cloudflared not found (public URL optional)"
  if [[ "$(uname)" == "Darwin" ]]; then
    command -v brew >/dev/null && ok "brew" || warn "brew not found (auto-install skipped)"
  fi
  hdr "Python"
  if [ -d "$ROOT_DIR/venv" ]; then
  "$ROOT_DIR/venv/bin/python" - <<'PY'
import sys
mods=["fastapi","uvicorn","sqlalchemy","pydantic","jose","python_dotenv","websockets","vlc"]
missing=[]
for m in mods:
  try:
    __import__(m)
  except Exception:
    missing.append(m)
if missing:
  print("[warn] missing modules:", ", ".join(missing))
else:
  print("[ok] Python deps present")
try:
  import vlc
  try:
    _=vlc.Instance()
    print("[ok] libVLC available")
  except Exception:
    print("[warn] libVLC not available; install VLC media player")
except Exception:
  pass
PY
  else
  warn "venv not found; run scripts/app/setup.sh"
  fi
}


# --- Raspberry Pi helpers ---
is_pi(){ [ -f /etc/raspberrypi-release ] || grep -qi 'raspberry' /proc/cpuinfo 2>/dev/null || grep -qi 'raspi' /proc/cpuinfo 2>/dev/null; }
cmd_pi_install(){ license_notice; if ! is_pi; then warn "Not a Raspberry Pi (continuing anyway)"; fi; sudo bash "$ROOT_DIR/scripts/pi/setup.sh"; }
cmd_pi_start(){
  license_notice
  if [ ! -f "$ROOT_DIR/.installed" ]; then warn "setup has not been run locally; proceeding with Pi systemd start"; fi
  sudo bash "$ROOT_DIR/scripts/pi/run.sh"
}
cmd_pi_stop(){ license_notice; sudo bash "$ROOT_DIR/scripts/pi/stop.sh"; }
cmd_pi_status(){ banner; systemctl --no-pager status vibrae-backend vibrae-frontend vibrae-cloudflared || true; }
cmd_pi_logs(){ local unit="${1:-vibrae-backend}"; journalctl -u "$unit" -f; }

# Enable extended glob for trimming
shopt -s extglob 2>/dev/null || true

run_interactive(){
  banner
  # attempt autostart if enabled
  autostart_maybe_start || true
  printf "Type 'help' for commands, 'quit' to exit.\n"
  while true; do
    if read -e -r -p "vibrae> " line; then
      # trim
      line="${line##+([[:space:]])}"
      line="${line%%+([[:space:]])}"
      case "$line" in
        "" ) continue ;;
        quit|exit ) break ;;
        help ) usage; echo; continue ;;
  clear ) clear 2>/dev/null || printf '\033c'; echo; continue ;;
      esac
      IFS=' ' read -r -a args <<< "$line"
  set +e
      dispatch "${args[@]}"
      rc=$?
      set -e
      echo
    else
      break
    fi
  done
}

dispatch(){
  # With 'set -u', $1 may be unset when no args are passed; default to empty
  case "${1-}" in
  --version|version) shift; echo "vibrae ${VERSION}"; return 0;;
    "" )
      # No command provided
      if [ ! -f "$ROOT_DIR/.installed" ] || [ ! -d "$ROOT_DIR/venv" ]; then
        onboarding_message
        return 0
      else
        run_interactive; return 0
      fi;;
    install) shift; cmd_install "$@";;
    start|up) shift; cmd_start "$@";;
    stop|down) shift; cmd_stop "$@";;
    restart) shift; cmd_restart "$@";;
    status) shift; cmd_status "$@";;
    logs) shift; cmd_logs "$@";;
  front) shift; case "$1" in restart) shift; cmd_front_restart ;; *) usage; return 1;; esac ;;
    open) shift; cmd_open "$@";;
    url) shift; cmd_url "$@";;

    contact) shift; contact_information "$@";;
    github) shift; cmd_github "$@";;

  env) shift; case "${1-}" in show|ls|cat) shift; cmd_env_show;; edit) shift; cmd_env_edit;; encrypt) shift; cmd_env_encrypt;; decrypt) shift; cmd_env_decrypt;; edit-sec) shift; cmd_env_edit_sec;; f-encrypt) shift; cmd_env_f_encrypt;; f-decrypt) shift; cmd_env_f_decrypt;; f-edit-sec) shift; cmd_env_f_edit_sec;; set) shift; cmd_env_set "$@";; get) shift; env_get "$@";; sync) shift; cmd_env_sync;; help) shift; env_help;; *) usage; return 1;; esac;;

  db) shift; case "${1-}" in init) shift; cmd_db_init ;; *) usage; return 1;; esac;;

    autostart) shift; cmd_autostart "$@";;
    source) shift; case "$1" in detect) shift; cmd_source_detect;; *) usage; return 1;; esac;;

  check-env|ce|check) shift; cmd_check_env;;
    doctor) shift; cmd_doctor;;
  clear) clear 2>/dev/null || printf '\033c';;
  pi) shift; case "${1-}" in install) shift; cmd_pi_install;; start) shift; cmd_pi_start;; stop) shift; cmd_pi_stop;; status) shift; cmd_pi_status;; logs) shift; cmd_pi_logs "$@";; *) usage; return 1;; esac;;
  ahelp) echo "Aliases:"; echo "  ver->version st->status ce->check-env doc->doctor"; echo "  sh->shell ls-env/env ls/env cat->env show"; echo "  up->start down->stop"; echo "  ahelp->this list";;
  ver) shift; echo "vibrae ${VERSION}";;
  st) shift; cmd_status "$@";;
  ce) shift; cmd_check_env;;
  doc) shift; cmd_doctor;;
  sh) shift; run_interactive;;
  ls-env) shift; cmd_env_show;;
  up) shift; cmd_start "$@";;
  down) shift; cmd_stop "$@";;
  help|--help|-h) usage;;
    shell|"") run_interactive;;
    *) err "Unknown command: $1"; usage; return 1;;
  esac
}

main(){
  _VIBRAE_TRAP_READY=1; export _VIBRAE_TRAP_READY;
  unset _VIBRAE_SUPPRESS_TRAP 2>/dev/null || true
  dispatch "$@";
}

# Enable -u late to avoid early false ERR triggers
if [ -n "${DEFER_SET_U:-}" ]; then
  set -u
  unset DEFER_SET_U
fi

main "$@"
